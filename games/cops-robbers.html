<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Cops & Robbers - Mall Escape!</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Lilita+One&family=Nunito:wght@600;700;800;900&display=swap" rel="stylesheet">
<link rel="stylesheet" href="../shared/controls-modal.css">
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --accent-blue: #3a7bd5;
    --accent-red: #ff4444;
    --accent-green: #2ed573;
    --accent-gold: #ffd700;
    --card-bg: rgba(255,255,255,0.08);
    --card-border: rgba(255,255,255,0.15);
    --dark-bg: #1a1a3e;
  }

  html, body { height: 100%; overflow: hidden; }

  body {
    font-family: 'Nunito', sans-serif;
    background: var(--dark-bg);
    color: #fff;
    -webkit-tap-highlight-color: transparent;
    touch-action: none;
    overscroll-behavior: none;
  }

  /* =========== SCREENS =========== */
  .screen {
    position: fixed;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 50;
    transition: opacity 0.35s, transform 0.35s;
    padding: 1.5rem;
  }
  .screen.hidden {
    opacity: 0;
    pointer-events: none;
    transform: scale(0.95);
  }

  .menu-bg {
    background: linear-gradient(170deg, #1a1040 0%, #2d1b69 40%, #1a1a4e 100%);
  }

  .screen h1 {
    font-family: 'Lilita One', cursive;
    font-size: clamp(2rem, 7vw, 3rem);
    margin-bottom: 0.3rem;
    text-align: center;
  }
  .screen h1 .gradient-text {
    background: linear-gradient(135deg, var(--accent-red), #fff, var(--accent-gold));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  .screen .subtitle {
    color: rgba(255,255,255,0.5);
    font-weight: 700;
    font-size: 0.9rem;
    margin-bottom: 1.5rem;
    text-align: center;
  }

  .choice-label {
    font-family: 'Lilita One', cursive;
    font-size: 1.1rem;
    margin-bottom: 0.8rem;
    color: rgba(255,255,255,0.7);
    letter-spacing: 1px;
  }

  .choice-row {
    display: flex;
    gap: 0.8rem;
    margin-bottom: 1.5rem;
    flex-wrap: wrap;
    justify-content: center;
  }

  .choice-btn {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.4rem;
    padding: 1rem 1.5rem;
    background: rgba(255,255,255,0.06);
    border: 2px solid rgba(255,255,255,0.1);
    border-radius: 1.2rem;
    color: #fff;
    font-family: 'Nunito', sans-serif;
    font-weight: 800;
    font-size: 0.9rem;
    cursor: pointer;
    transition: all 0.2s;
    min-width: 130px;
    -webkit-tap-highlight-color: transparent;
  }
  .choice-btn:active { transform: scale(0.95); }
  .choice-btn.selected {
    border-color: var(--accent-red);
    background: rgba(255,68,68,0.2);
    box-shadow: 0 0 20px rgba(255,68,68,0.3);
  }

  .char-preview {
    width: 64px;
    height: 80px;
    position: relative;
  }

  .go-btn {
    font-family: 'Nunito', sans-serif;
    font-weight: 800;
    font-size: 1.15rem;
    padding: 0.9rem 3rem;
    background: linear-gradient(135deg, var(--accent-red), #ff6b6b);
    color: #fff;
    border: none;
    border-radius: 1.2rem;
    cursor: pointer;
    margin-top: 0.5rem;
    transition: transform 0.15s, filter 0.15s, opacity 0.3s;
    letter-spacing: 0.5px;
  }
  .go-btn:active { transform: scale(0.95); filter: brightness(1.1); }
  .go-btn:disabled { opacity: 0.3; pointer-events: none; }

  .back-link {
    position: absolute;
    top: 1rem; left: 1rem;
    display: flex; align-items: center; gap: 0.3rem;
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.12);
    color: #ccc;
    font-family: 'Nunito', sans-serif;
    font-weight: 700;
    font-size: 0.85rem;
    padding: 0.45rem 0.9rem;
    border-radius: 2rem;
    cursor: pointer;
    text-decoration: none;
    transition: background 0.2s;
    z-index: 60;
  }
  .back-link:hover { background: rgba(255,255,255,0.14); color: #fff; }

  /* =========== GAME CANVAS =========== */
  #gameCanvas {
    position: fixed;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 1;
  }

  /* HUD */
  .hud {
    position: fixed;
    top: 0; left: 0; right: 0;
    z-index: 40;
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    padding: 0.8rem 1rem;
    pointer-events: none;
  }
  .hud.hidden { display: none; }

  .hud-item {
    background: rgba(0,0,0,0.5);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    padding: 0.5rem 0.9rem;
    border-radius: 1rem;
    pointer-events: auto;
  }
  .hud-label {
    font-size: 0.6rem;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: rgba(255,255,255,0.5);
    font-weight: 700;
  }
  .hud-value {
    font-family: 'Lilita One', cursive;
    font-size: 1.1rem;
    color: #fff;
  }

  /* Mobile controls - ALWAYS visible during game */
  .mobile-controls {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 100;
    display: none;
    padding: 0.5rem;
    pointer-events: none;
  }
  .mobile-controls.visible {
    display: flex !important;
  }

  .dpad {
    display: grid;
    grid-template-areas:
      ".  up  ."
      "left . right"
      ". down .";
    grid-template-columns: 70px 70px 70px;
    grid-template-rows: 70px 10px 70px;
    gap: 6px;
    pointer-events: auto;
  }

  .ctrl-btn {
    width: 70px;
    height: 70px;
    background: rgba(0,0,0,0.6);
    border: 3px solid rgba(100,200,255,0.9);
    border-radius: 1rem;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.8rem;
    color: rgb(100,200,255);
    cursor: pointer;
    user-select: none;
    -webkit-user-select: none;
    transition: background 0.1s, transform 0.1s;
  }
  .ctrl-btn:active, .ctrl-btn.pressed {
    background: rgba(100,200,255,0.4);
    transform: scale(0.95);
  }
  .ctrl-up    { grid-area: up; }
  .ctrl-down  { grid-area: down; }
  .ctrl-left  { grid-area: left; }
  .ctrl-right { grid-area: right; }

  /* Control labels */
  .ctrl-label {
    position: absolute;
    font-size: 0.6rem;
    color: rgba(255,255,255,0.6);
    font-weight: 700;
    text-transform: uppercase;
    pointer-events: none;
  }
  .ctrl-up .ctrl-label { bottom: 5px; }
  .ctrl-down .ctrl-label { top: 5px; }
  .ctrl-left .ctrl-label { right: 8px; }
  .ctrl-right .ctrl-label { left: 8px; }

  /* End overlay */
  .end-overlay {
    position: fixed;
    inset: 0;
    z-index: 80;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.6);
    backdrop-filter: blur(4px);
    -webkit-backdrop-filter: blur(4px);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s;
    padding: 1.5rem;
  }
  .end-overlay.visible {
    opacity: 1;
    pointer-events: auto;
  }
  .end-card {
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 1.4rem;
    padding: 2rem 1.5rem;
    text-align: center;
    max-width: 340px;
    width: 100%;
  }
  .end-emoji { font-size: 3rem; margin-bottom: 0.5rem; }
  .end-title {
    font-family: 'Lilita One', cursive;
    font-size: 1.6rem;
    margin-bottom: 0.3rem;
  }
  .end-msg { color: rgba(255,255,255,0.6); font-weight: 700; margin-bottom: 1rem; font-size: 0.95rem; }
  .end-btns { display: flex; flex-direction: column; gap: 0.5rem; }
  .end-btn {
    font-family: 'Nunito', sans-serif;
    font-weight: 800;
    font-size: 1rem;
    padding: 0.8rem;
    border: none;
    border-radius: 1rem;
    cursor: pointer;
    transition: transform 0.15s;
    text-decoration: none;
    text-align: center;
    display: block;
  }
  .end-btn:active { transform: scale(0.96); }
  .end-primary {
    background: linear-gradient(135deg, var(--accent-red), #ff6b6b);
    color: #fff;
  }
  .end-secondary {
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.12);
    color: #ccc;
  }
</style>
</head>
<body>

<!-- ===== CHARACTER SELECT SCREEN ===== -->
<div class="screen menu-bg" id="selectScreen">
  <a href="../index.html" class="back-link">‚Äπ Home</a>

  <div style="font-size:3rem; margin-bottom:0.5rem;">üè¨üíé</div>
  <h1><span class="gradient-text">Mall Escape!</span></h1>
  <p class="subtitle">Escape the mall with the jewelry before the cops catch you!</p>

  <div class="choice-label">CHOOSE YOUR ROBBER</div>
  <div class="choice-row" id="charRow">
    <button class="choice-btn" data-char="boy" onclick="selectChar('boy')">
      <canvas class="char-preview" id="previewBoy" width="64" height="80"></canvas>
      <span>Boy</span>
    </button>
    <button class="choice-btn" data-char="girl" onclick="selectChar('girl')">
      <canvas class="char-preview" id="previewGirl" width="64" height="80"></canvas>
      <span>Girl</span>
    </button>
  </div>

  <button class="go-btn" id="goBtn" disabled onclick="startGame()">Start Heist!</button>
</div>

<!-- ===== HOW TO PLAY MODAL ===== -->
<div class="controls-overlay" id="controlsOverlay">
  <div class="controls-card">
    <h2>How to Play</h2>
    <div class="controls-row">
      <div class="key-icon">üèÉ</div>
      <div class="key-desc">Find the EXIT to escape the mall!</div>
    </div>
    <div class="controls-row">
      <div class="key-icon">üëÆ</div>
      <div class="key-desc">Avoid the cops ‚Äî they'll arrest you!</div>
    </div>
    <div class="controls-row">
      <div class="key-icon">‚ñ≤‚ñº</div>
      <div class="key-desc">Move forward / backward</div>
    </div>
    <div class="controls-row">
      <div class="key-icon">‚óÄ‚ñ∂</div>
      <div class="key-desc">Turn left / right</div>
    </div>
    <button class="controls-go-btn" onclick="dismissControls()">Got it!</button>
  </div>
</div>

<!-- ===== GAME AREA ===== -->
<div class="screen game-bg hidden" id="gameArea">
  <canvas id="gameCanvas"></canvas>
</div>

<!-- HUD -->
<div class="hud hidden" id="hud">
  <div class="hud-item">
    <div class="hud-label">Loot</div>
    <div class="hud-value" id="hudLoot">üíéüí∞</div>
  </div>
  <div class="hud-item">
    <div class="hud-label">Status</div>
    <div class="hud-value" id="hudStatus">On the run!</div>
  </div>
</div>

<!-- Mobile controls -->
<div class="mobile-controls" id="mobileControls">
  <div class="dpad">
    <div class="ctrl-btn ctrl-up" id="btnUp">‚ñ≤</div>
    <div class="ctrl-btn ctrl-left" id="btnLeft">‚óÄ</div>
    <div class="ctrl-btn ctrl-right" id="btnRight">‚ñ∂</div>
    <div class="ctrl-btn ctrl-down" id="btnDown">‚ñº</div>
  </div>
</div>

<!-- ===== END OVERLAY ===== -->
<div class="end-overlay" id="endOverlay">
  <div class="end-card">
    <div class="end-emoji" id="endEmoji">üöî</div>
    <div class="end-title" id="endTitle">Caught!</div>
    <div class="end-msg" id="endMsg">You're going to jail!</div>
    <div class="end-btns">
      <button class="end-btn end-primary" onclick="restartGame()">Try Again</button>
      <a class="end-btn end-secondary" href="../index.html">Home</a>
    </div>
  </div>
</div>

<script>
// ===== CONSTANTS =====
const TILE = 64; // Larger tiles for mall
const PLAYER_SPEED = 3;
const TURN_SPEED = 0.06;
const COP_SPEED = 1.8;
const NUM_COPS = 2;
const NUM_CIVILIANS = 8;
const FOV = Math.PI / 2; // 90 degree field of view
const VIEW_DISTANCE = 20; // How far we can see in tiles

// Store types with colors and names
const STORE_TYPES = [
  { name: 'ELECTRONICS', color: '#3498db', accent: '#2980b9' },
  { name: 'FASHION', color: '#e84393', accent: '#d63384' },
  { name: 'FOOD COURT', color: '#2ed573', accent: '#26c264' },
  { name: 'JEWELRY', color: '#ffd700', accent: '#ffcc00' },
  { name: 'SPORTS', color: '#e67e22', accent: '#d35400' },
  { name: 'TOYS', color: '#9b59b6', accent: '#8e44ad' },
  { name: 'BOOKS', color: '#795548', accent: '#5d4037' },
  { name: 'SHOES', color: '#00bcd4', accent: '#0097a7' }
];

// Mall layout: 0=wall, 1=floor, 2=start (jewelry store), 3=exit
// Larger mall with exit far from start - player must explore to find it
const MALL = [
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,3,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0],
  [0,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0],
  [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
  [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
  [0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0],
  [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
  [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
  [0,1,1,0,1,1,0,0,0,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,0],
  [0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0],
  [0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0],
  [0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0],
  [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
  [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
  [0,1,1,0,1,1,0,0,0,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,0],
  [0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0],
  [0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0],
  [0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0],
  [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
  [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
  [0,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,1,0],
  [0,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
];

const MALL_H = MALL.length;
const MALL_W = MALL[0].length;

// ===== STATE =====
let selectedChar = null;
let gameRunning = false;
let animId = null;
let canvas, ctx, W, H;

// Player state with position and angle
let player = { x: 0, y: 0, angle: 0 };
let cops = [];
let civilians = [];
let startTile = { r: 0, c: 0 };
let exitTile = { r: 0, c: 0 };

// Store assignments for walls
let storeMap = new Map();

// Arrest mechanic - cops must touch player for 3 continuous seconds
const ARREST_TIME = 3000; // 3 seconds in milliseconds
let arrestStartTime = null;
let beingArrested = false;

const keys = { forward: false, backward: false, turnLeft: false, turnRight: false };

// ===== FIND SPECIAL TILES & ASSIGN STORES =====
function initMall() {
  storeMap.clear();
  let storeIndex = 0;

  for (let r = 0; r < MALL_H; r++) {
    for (let c = 0; c < MALL_W; c++) {
      if (MALL[r][c] === 2) {
        startTile = { r, c };
      }
      if (MALL[r][c] === 3) {
        exitTile = { r, c };
      }
      // Assign stores to wall tiles that are adjacent to floor
      if (MALL[r][c] === 0) {
        const neighbors = [
          [r-1, c], [r+1, c], [r, c-1], [r, c+1]
        ];
        for (const [nr, nc] of neighbors) {
          if (nr >= 0 && nr < MALL_H && nc >= 0 && nc < MALL_W && MALL[nr][nc] >= 1) {
            storeMap.set(`${r},${c}`, STORE_TYPES[storeIndex % STORE_TYPES.length]);
            storeIndex++;
            break;
          }
        }
      }
    }
  }
}
initMall();

// ===== CHARACTER DRAWING (back view for third person) =====
function drawRobberBack(ctx, x, y, type, size) {
  const s = size;
  const half = s / 2;

  ctx.save();
  ctx.translate(x, y);

  // Legs (walking animation based on time)
  const walkPhase = Math.sin(Date.now() * 0.01) * 0.15;
  ctx.fillStyle = '#444';
  const legTop = s * 0.15;
  ctx.fillRect(-half * 0.35 + walkPhase * 10, legTop, s * 0.18, s * 0.35);
  ctx.fillRect(half * 0.15 - walkPhase * 10, legTop, s * 0.18, s * 0.35);

  // Body (striped shirt - back view)
  const bodyTop = -s * 0.25;
  const bodyH = s * 0.45;
  ctx.fillStyle = '#fff';
  ctx.fillRect(-half * 0.5, bodyTop, s * 0.5, bodyH);
  // Stripes
  ctx.fillStyle = '#222';
  const stripeH = bodyH / 5;
  for (let i = 0; i < 5; i += 2) {
    ctx.fillRect(-half * 0.5, bodyTop + i * stripeH, s * 0.5, stripeH);
  }

  // Loot bag on back
  ctx.fillStyle = '#8B6914';
  ctx.beginPath();
  ctx.ellipse(0, bodyTop + bodyH * 0.4, s * 0.25, s * 0.3, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#ffd700';
  ctx.font = `bold ${s * 0.2}px serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('$', 0, bodyTop + bodyH * 0.4);

  // Head (back of head)
  const headR = s * 0.22;
  const headY = bodyTop - headR * 0.3;
  ctx.fillStyle = '#f4c078';
  ctx.beginPath();
  ctx.arc(0, headY, headR, 0, Math.PI * 2);
  ctx.fill();

  if (type === 'boy') {
    // Hat (back view)
    ctx.fillStyle = '#333';
    ctx.fillRect(-headR * 1.0, headY - headR * 1.0, headR * 2.0, headR * 0.5);
    ctx.fillRect(-headR * 0.8, headY - headR * 1.4, headR * 1.6, headR * 0.5);
    // Hair visible below hat
    ctx.fillStyle = '#3a2010';
    ctx.fillRect(-headR * 0.7, headY + headR * 0.3, headR * 1.4, headR * 0.4);
  } else {
    // Pigtails (back view) - ponytails hanging down
    ctx.fillStyle = '#8B4513';
    // Back of hair on head
    ctx.beginPath();
    ctx.arc(0, headY, headR * 0.95, 0, Math.PI * 2);
    ctx.fill();
    // Left pigtail - ponytail hanging down
    ctx.beginPath();
    ctx.moveTo(-headR * 0.8, headY);
    ctx.quadraticCurveTo(-headR * 1.3, headY + headR * 0.5, -headR * 1.1, headY + headR * 1.5);
    ctx.quadraticCurveTo(-headR * 0.9, headY + headR * 1.8, -headR * 1.0, headY + headR * 2.0);
    ctx.lineTo(-headR * 0.7, headY + headR * 1.8);
    ctx.quadraticCurveTo(-headR * 0.6, headY + headR * 1.4, -headR * 0.7, headY + headR * 0.8);
    ctx.quadraticCurveTo(-headR * 0.6, headY + headR * 0.3, -headR * 0.8, headY);
    ctx.fill();
    // Right pigtail - ponytail hanging down
    ctx.beginPath();
    ctx.moveTo(headR * 0.8, headY);
    ctx.quadraticCurveTo(headR * 1.3, headY + headR * 0.5, headR * 1.1, headY + headR * 1.5);
    ctx.quadraticCurveTo(headR * 0.9, headY + headR * 1.8, headR * 1.0, headY + headR * 2.0);
    ctx.lineTo(headR * 0.7, headY + headR * 1.8);
    ctx.quadraticCurveTo(headR * 0.6, headY + headR * 1.4, headR * 0.7, headY + headR * 0.8);
    ctx.quadraticCurveTo(headR * 0.6, headY + headR * 0.3, headR * 0.8, headY);
    ctx.fill();
    // Hair ties (pink bands)
    ctx.fillStyle = '#ff6b9d';
    ctx.beginPath();
    ctx.ellipse(-headR * 0.85, headY + headR * 0.15, headR * 0.18, headR * 0.1, -0.3, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(headR * 0.85, headY + headR * 0.15, headR * 0.18, headR * 0.1, 0.3, 0, Math.PI * 2);
    ctx.fill();
    // Re-draw head skin visible at neck
    ctx.fillStyle = '#f4c078';
    ctx.fillRect(-headR * 0.3, headY + headR * 0.6, headR * 0.6, headR * 0.3);
  }

  ctx.restore();
}

function drawRobberFront(ctx, x, y, type, size) {
  const s = size;
  const half = s / 2;

  ctx.save();
  ctx.translate(x, y);

  // Body (striped shirt)
  const bodyTop = -s * 0.15;
  const bodyH = s * 0.4;
  ctx.fillStyle = '#fff';
  ctx.fillRect(-half * 0.5, bodyTop, s * 0.5, bodyH);
  // Stripes
  ctx.fillStyle = '#222';
  const stripeH = bodyH / 5;
  for (let i = 0; i < 5; i += 2) {
    ctx.fillRect(-half * 0.5, bodyTop + i * stripeH, s * 0.5, stripeH);
  }

  // Head
  const headR = s * 0.2;
  const headY = bodyTop - headR * 0.6;
  ctx.fillStyle = '#f4c078';
  ctx.beginPath();
  ctx.arc(0, headY, headR, 0, Math.PI * 2);
  ctx.fill();

  // Mask
  ctx.fillStyle = '#222';
  ctx.fillRect(-headR * 0.9, headY - headR * 0.25, headR * 1.8, headR * 0.5);

  // Eyes (white dots on mask)
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(-headR * 0.35, headY - headR * 0.05, headR * 0.15, 0, Math.PI * 2);
  ctx.arc(headR * 0.35, headY - headR * 0.05, headR * 0.15, 0, Math.PI * 2);
  ctx.fill();

  if (type === 'boy') {
    ctx.fillStyle = '#333';
    ctx.fillRect(-headR * 1.0, headY - headR * 1.2, headR * 2.0, headR * 0.4);
    ctx.fillRect(-headR * 0.7, headY - headR * 1.6, headR * 1.4, headR * 0.5);
  } else {
    // Pigtails (front view) - ponytails hanging down on sides
    ctx.fillStyle = '#8B4513';
    // Hair on top of head
    ctx.beginPath();
    ctx.arc(0, headY - headR * 0.3, headR * 0.9, Math.PI, 0);
    ctx.fill();
    // Left pigtail hanging down
    ctx.beginPath();
    ctx.moveTo(-headR * 0.9, headY - headR * 0.1);
    ctx.quadraticCurveTo(-headR * 1.4, headY + headR * 0.3, -headR * 1.2, headY + headR * 1.0);
    ctx.quadraticCurveTo(-headR * 1.1, headY + headR * 1.4, -headR * 1.15, headY + headR * 1.6);
    ctx.lineTo(-headR * 0.85, headY + headR * 1.4);
    ctx.quadraticCurveTo(-headR * 0.8, headY + headR * 1.0, -headR * 0.9, headY + headR * 0.5);
    ctx.quadraticCurveTo(-headR * 0.85, headY, -headR * 0.9, headY - headR * 0.1);
    ctx.fill();
    // Right pigtail hanging down
    ctx.beginPath();
    ctx.moveTo(headR * 0.9, headY - headR * 0.1);
    ctx.quadraticCurveTo(headR * 1.4, headY + headR * 0.3, headR * 1.2, headY + headR * 1.0);
    ctx.quadraticCurveTo(headR * 1.1, headY + headR * 1.4, headR * 1.15, headY + headR * 1.6);
    ctx.lineTo(headR * 0.85, headY + headR * 1.4);
    ctx.quadraticCurveTo(headR * 0.8, headY + headR * 1.0, headR * 0.9, headY + headR * 0.5);
    ctx.quadraticCurveTo(headR * 0.85, headY, headR * 0.9, headY - headR * 0.1);
    ctx.fill();
    // Hair ties (pink bands)
    ctx.fillStyle = '#ff6b9d';
    ctx.beginPath();
    ctx.ellipse(-headR * 0.95, headY + headR * 0.05, headR * 0.15, headR * 0.1, -0.3, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(headR * 0.95, headY + headR * 0.05, headR * 0.15, headR * 0.1, 0.3, 0, Math.PI * 2);
    ctx.fill();
  }

  // Legs
  ctx.fillStyle = '#444';
  const legTop = bodyTop + bodyH;
  ctx.fillRect(-half * 0.35, legTop, s * 0.15, s * 0.3);
  ctx.fillRect(half * 0.15, legTop, s * 0.15, s * 0.3);

  ctx.restore();
}

function drawCopSprite(ctx, x, y, size, facing) {
  const s = size;
  const half = s / 2;

  ctx.save();
  ctx.translate(x, y);

  // Body (blue uniform)
  const bodyTop = -s * 0.15;
  const bodyH = s * 0.4;
  ctx.fillStyle = '#1a3a6a';
  ctx.fillRect(-half * 0.5, bodyTop, s * 0.5, bodyH);

  // Badge (only if facing forward)
  if (facing === 'front') {
    ctx.fillStyle = '#ffd700';
    ctx.beginPath();
    ctx.arc(half * 0.1, bodyTop + bodyH * 0.3, s * 0.06, 0, Math.PI * 2);
    ctx.fill();
  }

  // Head
  const headR = s * 0.2;
  const headY = bodyTop - headR * 0.6;
  ctx.fillStyle = '#f4c078';
  ctx.beginPath();
  ctx.arc(0, headY, headR, 0, Math.PI * 2);
  ctx.fill();

  // Police hat
  ctx.fillStyle = '#1a2a4a';
  ctx.fillRect(-headR * 1.0, headY - headR * 1.1, headR * 2.0, headR * 0.35);
  ctx.fillRect(-headR * 0.7, headY - headR * 1.5, headR * 1.4, headR * 0.5);
  // Hat badge
  ctx.fillStyle = '#ffd700';
  ctx.beginPath();
  ctx.arc(0, headY - headR * 1.1, headR * 0.15, 0, Math.PI * 2);
  ctx.fill();

  if (facing === 'front') {
    // Eyes
    ctx.fillStyle = '#222';
    ctx.beginPath();
    ctx.arc(-headR * 0.35, headY - headR * 0.05, headR * 0.1, 0, Math.PI * 2);
    ctx.arc(headR * 0.35, headY - headR * 0.05, headR * 0.1, 0, Math.PI * 2);
    ctx.fill();
  }

  // Legs
  ctx.fillStyle = '#1a2a4a';
  const legTop = bodyTop + bodyH;
  ctx.fillRect(-half * 0.35, legTop, s * 0.15, s * 0.3);
  ctx.fillRect(half * 0.15, legTop, s * 0.15, s * 0.3);

  ctx.restore();
}

function drawCivilianSprite(ctx, x, y, size, variant) {
  const s = size;
  const half = s / 2;
  const colors = ['#e74c3c','#3498db','#2ecc71','#f39c12','#9b59b6','#1abc9c','#e67e22','#e84393'];

  ctx.save();
  ctx.translate(x, y);

  // Body
  const bodyTop = -s * 0.15;
  const bodyH = s * 0.4;
  ctx.fillStyle = colors[variant % colors.length];
  ctx.fillRect(-half * 0.45, bodyTop, s * 0.45, bodyH);

  // Head
  const headR = s * 0.18;
  const headY = bodyTop - headR * 0.6;
  ctx.fillStyle = '#f4c078';
  ctx.beginPath();
  ctx.arc(0, headY, headR, 0, Math.PI * 2);
  ctx.fill();

  // Hair
  const hairColors = ['#3a2010','#8B4513','#DAA520','#2c1810','#c0392b','#555'];
  ctx.fillStyle = hairColors[variant % hairColors.length];
  ctx.beginPath();
  ctx.arc(0, headY - headR * 0.3, headR * 0.9, Math.PI, 0);
  ctx.fill();

  // Legs
  ctx.fillStyle = '#555';
  const legTop = bodyTop + bodyH;
  ctx.fillRect(-half * 0.3, legTop, s * 0.12, s * 0.25);
  ctx.fillRect(half * 0.1, legTop, s * 0.12, s * 0.25);

  ctx.restore();
}

// ===== DRAW PREVIEWS =====
function drawPreview(canvasId, type) {
  const c = document.getElementById(canvasId);
  const ct = c.getContext('2d');
  ct.clearRect(0, 0, 64, 80);
  drawRobberFront(ct, 32, 50, type, 50);
}
drawPreview('previewBoy', 'boy');
drawPreview('previewGirl', 'girl');

// ===== CHARACTER SELECTION =====
function selectChar(type) {
  selectedChar = type;
  document.querySelectorAll('.choice-btn').forEach(b => b.classList.remove('selected'));
  document.querySelector(`.choice-btn[data-char="${type}"]`).classList.add('selected');
  document.getElementById('goBtn').disabled = false;
}

// ===== PATHFINDING (for cops) =====
function getFloorNeighbors(r, c) {
  const dirs = [[0,1],[0,-1],[1,0],[-1,0]];
  const results = [];
  for (const [dr, dc] of dirs) {
    const nr = r + dr, nc = c + dc;
    if (nr >= 0 && nr < MALL_H && nc >= 0 && nc < MALL_W && MALL[nr][nc] >= 1) {
      results.push({ r: nr, c: nc });
    }
  }
  return results;
}

function bfsDirection(fromR, fromC, toR, toC) {
  if (fromR === toR && fromC === toC) return null;

  const visited = new Set();
  const queue = [{ r: fromR, c: fromC, firstDir: null }];
  visited.add(fromR * MALL_W + fromC);

  while (queue.length > 0) {
    const cur = queue.shift();
    const neighbors = getFloorNeighbors(cur.r, cur.c);
    for (const n of neighbors) {
      const key = n.r * MALL_W + n.c;
      if (visited.has(key)) continue;
      visited.add(key);

      const dir = cur.firstDir || { dr: n.r - cur.r, dc: n.c - cur.c };
      if (n.r === toR && n.c === toC) return dir;
      queue.push({ r: n.r, c: n.c, firstDir: dir });
    }
  }
  return null;
}

// ===== SPAWN NPCs =====
function getFloorTiles() {
  const tiles = [];
  for (let r = 0; r < MALL_H; r++) {
    for (let c = 0; c < MALL_W; c++) {
      if (MALL[r][c] >= 1) tiles.push({ r, c });
    }
  }
  return tiles;
}

function spawnNPCs() {
  cops = [];
  civilians = [];
  const floor = getFloorTiles();

  // Exclude tiles near start
  const farTiles = floor.filter(t =>
    Math.abs(t.r - startTile.r) + Math.abs(t.c - startTile.c) > 4
  );

  // Spawn cops
  for (let i = 0; i < NUM_COPS; i++) {
    const t = farTiles[Math.floor(Math.random() * farTiles.length)];
    cops.push({
      x: t.c * TILE + TILE / 2,
      y: t.r * TILE + TILE / 2,
      dir: null,
      moveTimer: 0,
      patrolTarget: null,
      chasing: false
    });
  }

  // Spawn civilians
  for (let i = 0; i < NUM_CIVILIANS; i++) {
    const t = floor[Math.floor(Math.random() * floor.length)];
    civilians.push({
      x: t.c * TILE + TILE / 2,
      y: t.r * TILE + TILE / 2,
      variant: i,
      dx: 0, dy: 0,
      moveTimer: 0
    });
  }
}

// ===== COLLISION WITH WALLS =====
function canMove(x, y, radius) {
  const offsets = [
    [-radius, -radius], [radius, -radius],
    [-radius, radius], [radius, radius]
  ];
  for (const [ox, oy] of offsets) {
    const c = Math.floor((x + ox) / TILE);
    const r = Math.floor((y + oy) / TILE);
    if (r < 0 || r >= MALL_H || c < 0 || c >= MALL_W) return false;
    if (MALL[r][c] === 0) return false;
  }
  return true;
}

// ===== RAYCASTING FOR 3D VIEW =====
function castRay(angle) {
  const px = player.x;
  const py = player.y;
  const dx = Math.cos(angle);
  const dy = Math.sin(angle);

  let dist = 0;
  const step = 2;
  const maxDist = VIEW_DISTANCE * TILE;

  while (dist < maxDist) {
    const checkX = px + dx * dist;
    const checkY = py + dy * dist;
    const col = Math.floor(checkX / TILE);
    const row = Math.floor(checkY / TILE);

    if (row < 0 || row >= MALL_H || col < 0 || col >= MALL_W) {
      return { dist, hit: true, row, col, side: 0 };
    }

    if (MALL[row][col] === 0) {
      // Determine which side was hit
      const prevX = px + dx * (dist - step);
      const prevY = py + dy * (dist - step);
      const prevCol = Math.floor(prevX / TILE);
      const prevRow = Math.floor(prevY / TILE);
      const side = (col !== prevCol) ? 0 : 1; // 0 = vertical wall, 1 = horizontal
      return { dist, hit: true, row, col, side };
    }

    dist += step;
  }

  return { dist: maxDist, hit: false, row: -1, col: -1, side: 0 };
}

// ===== GAME START =====
function startGame() {
  document.getElementById('selectScreen').classList.add('hidden');
  document.getElementById('controlsOverlay').classList.add('visible');
}

function dismissControls() {
  document.getElementById('controlsOverlay').classList.remove('visible');
  beginGame();
}

function beginGame() {
  canvas = document.getElementById('gameCanvas');
  ctx = canvas.getContext('2d');
  resizeCanvas();

  document.getElementById('gameArea').classList.remove('hidden');
  document.getElementById('hud').classList.remove('hidden');

  // Always show mobile controls
  document.getElementById('mobileControls').classList.add('visible');

  // Init player at start tile, facing right (east) - away from exit
  player.x = startTile.c * TILE + TILE / 2;
  player.y = startTile.r * TILE + TILE / 2;
  player.angle = 0; // Facing right (east) - player must explore to find exit

  // Reset arrest state
  beingArrested = false;
  arrestStartTime = null;

  spawnNPCs();
  gameRunning = true;
  gameLoop();
}

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  W = canvas.width;
  H = canvas.height;
}
window.addEventListener('resize', () => {
  if (canvas) resizeCanvas();
});

// ===== INPUT =====
document.addEventListener('keydown', e => {
  if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W')    { keys.forward = true; e.preventDefault(); }
  if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S')   { keys.backward = true; e.preventDefault(); }
  if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A')   { keys.turnLeft = true; e.preventDefault(); }
  if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D')  { keys.turnRight = true; e.preventDefault(); }
});
document.addEventListener('keyup', e => {
  if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W')    keys.forward = false;
  if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S')   keys.backward = false;
  if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A')   keys.turnLeft = false;
  if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D')  keys.turnRight = false;
});

function setupCtrl(id, keyName) {
  const el = document.getElementById(id);
  const start = () => { keys[keyName] = true; el.classList.add('pressed'); };
  const end = () => { keys[keyName] = false; el.classList.remove('pressed'); };
  el.addEventListener('touchstart', e => { e.preventDefault(); start(); }, { passive: false });
  el.addEventListener('touchend', e => { e.preventDefault(); end(); }, { passive: false });
  el.addEventListener('touchcancel', e => { e.preventDefault(); end(); }, { passive: false });
  el.addEventListener('mousedown', start);
  el.addEventListener('mouseup', end);
  el.addEventListener('mouseleave', end);
}
setupCtrl('btnUp', 'forward');
setupCtrl('btnDown', 'backward');
setupCtrl('btnLeft', 'turnLeft');
setupCtrl('btnRight', 'turnRight');

// ===== UPDATE =====
function update() {
  // Turn left/right
  if (keys.turnLeft) player.angle -= TURN_SPEED;
  if (keys.turnRight) player.angle += TURN_SPEED;

  // Keep angle in range [0, 2*PI)
  while (player.angle < 0) player.angle += Math.PI * 2;
  while (player.angle >= Math.PI * 2) player.angle -= Math.PI * 2;

  // Move forward/backward
  let moveDir = 0;
  if (keys.forward) moveDir = 1;
  if (keys.backward) moveDir = -0.6; // Slower backwards

  if (moveDir !== 0) {
    const dx = Math.cos(player.angle) * PLAYER_SPEED * moveDir;
    const dy = Math.sin(player.angle) * PLAYER_SPEED * moveDir;
    const pRad = TILE * 0.25;

    if (canMove(player.x + dx, player.y, pRad)) {
      player.x += dx;
    }
    if (canMove(player.x, player.y + dy, pRad)) {
      player.y += dy;
    }
  }

  // Check exit
  const pCol = Math.floor(player.x / TILE);
  const pRow = Math.floor(player.y / TILE);
  if (pRow === exitTile.r && pCol === exitTile.c) {
    endGame(true);
    return;
  }

  // Update cops
  const playerTileR = Math.floor(player.y / TILE);
  const playerTileC = Math.floor(player.x / TILE);

  for (const cop of cops) {
    const copR = Math.floor(cop.y / TILE);
    const copC = Math.floor(cop.x / TILE);

    const dist = Math.abs(copR - playerTileR) + Math.abs(copC - playerTileC);
    cop.chasing = dist <= 6;

    let targetR, targetC;
    if (cop.chasing) {
      targetR = playerTileR;
      targetC = playerTileC;
    } else {
      cop.moveTimer--;
      if (cop.moveTimer <= 0 || !cop.patrolTarget) {
        const floor = getFloorNeighbors(copR, copC);
        if (floor.length > 0) {
          const allFloor = getFloorTiles();
          const nearby = allFloor.filter(t =>
            Math.abs(t.r - copR) + Math.abs(t.c - copC) < 8 &&
            Math.abs(t.r - copR) + Math.abs(t.c - copC) > 2
          );
          cop.patrolTarget = nearby.length > 0
            ? nearby[Math.floor(Math.random() * nearby.length)]
            : floor[Math.floor(Math.random() * floor.length)];
        }
        cop.moveTimer = 100;
      }
      if (cop.patrolTarget) {
        targetR = cop.patrolTarget.r;
        targetC = cop.patrolTarget.c;
      } else {
        continue;
      }
    }

    const dir = bfsDirection(copR, copC, targetR, targetC);
    if (dir) {
      const speed = cop.chasing ? COP_SPEED * 1.4 : COP_SPEED;
      const newX = cop.x + dir.dc * speed;
      const newY = cop.y + dir.dr * speed;
      const npcRad = TILE * 0.2;
      if (canMove(newX, cop.y, npcRad)) cop.x = newX;
      if (canMove(cop.x, newY, npcRad)) cop.y = newY;
    }

  }

  // Check if any cop is physically touching the player (for arrest mechanic)
  // Must be very close - actual physical contact, not just nearby
  let copTouching = false;
  for (const cop of cops) {
    const cdx = cop.x - player.x;
    const cdy = cop.y - player.y;
    const distance = Math.sqrt(cdx * cdx + cdy * cdy);
    // Tight touch radius - cop must be right on top of player
    if (distance < TILE * 0.4) {
      copTouching = true;
      break;
    }
  }

  // Arrest mechanic - requires 3 seconds of continuous contact
  if (copTouching) {
    if (!beingArrested) {
      // Start arrest timer
      beingArrested = true;
      arrestStartTime = Date.now();
    } else {
      // Check if 3 seconds have passed
      const elapsed = Date.now() - arrestStartTime;
      if (elapsed >= ARREST_TIME) {
        endGame(false);
        return;
      }
    }
  } else {
    // Player escaped - reset arrest timer
    beingArrested = false;
    arrestStartTime = null;
  }

  // Update civilians (random wander)
  for (const civ of civilians) {
    civ.moveTimer--;
    if (civ.moveTimer <= 0) {
      const civR = Math.floor(civ.y / TILE);
      const civC = Math.floor(civ.x / TILE);
      const neighbors = getFloorNeighbors(civR, civC);
      if (neighbors.length > 0) {
        const target = neighbors[Math.floor(Math.random() * neighbors.length)];
        civ.dx = (target.c - civC) * 0.5;
        civ.dy = (target.r - civR) * 0.5;
      }
      civ.moveTimer = 40 + Math.floor(Math.random() * 60);
    }
    const npcRad = TILE * 0.15;
    const nx = civ.x + civ.dx;
    const ny = civ.y + civ.dy;
    if (canMove(nx, civ.y, npcRad)) civ.x = nx;
    if (canMove(civ.x, ny, npcRad)) civ.y = ny;
  }
}

// ===== RENDER 3D VIEW =====
function render() {
  ctx.clearRect(0, 0, W, H);

  // Draw sky/ceiling gradient
  const skyGrad = ctx.createLinearGradient(0, 0, 0, H / 2);
  skyGrad.addColorStop(0, '#2a1a4a');
  skyGrad.addColorStop(1, '#1a1a3e');
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, W, H / 2);

  // Ceiling lights
  const horizon = H / 2;
  for (let i = 0; i < 8; i++) {
    const lightX = (i + 0.5) * (W / 8);
    const lightY = horizon * 0.3;
    const grad = ctx.createRadialGradient(lightX, lightY, 0, lightX, lightY, 40);
    grad.addColorStop(0, 'rgba(255, 255, 200, 0.3)');
    grad.addColorStop(1, 'rgba(255, 255, 200, 0)');
    ctx.fillStyle = grad;
    ctx.fillRect(lightX - 50, lightY - 30, 100, 60);
  }

  // Draw floor with perspective
  const floorGrad = ctx.createLinearGradient(0, H / 2, 0, H);
  floorGrad.addColorStop(0, '#8a7a5a');
  floorGrad.addColorStop(1, '#5a4a3a');
  ctx.fillStyle = floorGrad;
  ctx.fillRect(0, H / 2, W, H / 2);

  // Floor tile pattern
  for (let y = horizon; y < H; y += 20) {
    const distRatio = (y - horizon) / (H - horizon);
    const alpha = 0.1 + distRatio * 0.1;
    ctx.strokeStyle = `rgba(0, 0, 0, ${alpha})`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(W, y);
    ctx.stroke();
  }

  // Raycasting for walls
  const numRays = Math.floor(W / 2);
  const wallData = [];

  for (let i = 0; i < numRays; i++) {
    const rayAngle = player.angle - FOV / 2 + (i / numRays) * FOV;
    const ray = castRay(rayAngle);

    // Correct fish-eye effect
    const correctedDist = ray.dist * Math.cos(rayAngle - player.angle);

    wallData.push({
      screenX: (i / numRays) * W,
      dist: correctedDist,
      hit: ray.hit,
      row: ray.row,
      col: ray.col,
      side: ray.side
    });
  }

  // Draw walls
  for (let i = 0; i < wallData.length; i++) {
    const data = wallData[i];
    if (!data.hit) continue;

    const wallHeight = Math.min(H * 2, (TILE * H * 0.8) / data.dist);
    const wallTop = horizon - wallHeight / 2;
    const screenX = data.screenX;
    const sliceWidth = Math.ceil(W / numRays) + 1;

    // Get store color for this wall
    const store = storeMap.get(`${data.row},${data.col}`);
    let wallColor = '#3a3a5c';
    let accentColor = '#2a2a4c';

    if (store) {
      wallColor = store.color;
      accentColor = store.accent;
    }

    // Darken based on distance and side
    const brightness = Math.max(0.3, 1 - data.dist / (VIEW_DISTANCE * TILE));
    const sideFactor = data.side === 1 ? 0.8 : 1;

    // Draw wall slice
    ctx.fillStyle = shadeColor(wallColor, brightness * sideFactor);
    ctx.fillRect(screenX, wallTop, sliceWidth, wallHeight);

    // Add store sign effect for nearby walls
    if (data.dist < TILE * 5 && store) {
      const signHeight = wallHeight * 0.2;
      const signTop = wallTop + wallHeight * 0.15;
      ctx.fillStyle = shadeColor(accentColor, brightness * sideFactor * 0.8);
      ctx.fillRect(screenX, signTop, sliceWidth, signHeight);
    }

    // Wall edge lines for depth
    if (i > 0 && Math.abs(wallData[i].dist - wallData[i-1].dist) > TILE * 0.5) {
      ctx.strokeStyle = `rgba(0,0,0,${0.5 * brightness})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(screenX, wallTop);
      ctx.lineTo(screenX, wallTop + wallHeight);
      ctx.stroke();
    }
  }

  // Draw exit sign if visible
  drawExitSign();

  // Draw NPCs (sorted by distance, far to near)
  const entities = [];

  // Add cops
  for (const cop of cops) {
    const dx = cop.x - player.x;
    const dy = cop.y - player.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx);
    entities.push({ type: 'cop', x: cop.x, y: cop.y, dist, angle, chasing: cop.chasing });
  }

  // Add civilians
  for (const civ of civilians) {
    const dx = civ.x - player.x;
    const dy = civ.y - player.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx);
    entities.push({ type: 'civilian', x: civ.x, y: civ.y, dist, angle, variant: civ.variant });
  }

  // Sort by distance (far to near)
  entities.sort((a, b) => b.dist - a.dist);

  // Draw entities
  for (const entity of entities) {
    drawEntity(entity);
  }

  // Draw player character (back view, fixed at bottom center)
  const playerSize = Math.min(W * 0.25, H * 0.35);
  const playerX = W / 2;
  const playerY = H - playerSize * 0.6;
  drawRobberBack(ctx, playerX, playerY, selectedChar, playerSize);

  // Draw minimap
  drawMinimap();

  // Draw compass
  drawCompass();

  // Draw arrest progress bar if being arrested
  if (beingArrested && arrestStartTime) {
    drawArrestBar();
  }
}

function shadeColor(color, factor) {
  const hex = color.replace('#', '');
  const r = Math.floor(parseInt(hex.substr(0, 2), 16) * factor);
  const g = Math.floor(parseInt(hex.substr(2, 2), 16) * factor);
  const b = Math.floor(parseInt(hex.substr(4, 2), 16) * factor);
  return `rgb(${r},${g},${b})`;
}

function drawEntity(entity) {
  // Check if entity is in view
  let relAngle = entity.angle - player.angle;
  while (relAngle < -Math.PI) relAngle += Math.PI * 2;
  while (relAngle > Math.PI) relAngle -= Math.PI * 2;

  if (Math.abs(relAngle) > FOV / 2 + 0.2) return; // Not in view
  if (entity.dist > VIEW_DISTANCE * TILE) return; // Too far
  if (entity.dist < TILE * 0.3) return; // Too close

  // Calculate screen position
  const screenX = W / 2 + (relAngle / (FOV / 2)) * (W / 2);
  const screenY = H / 2; // Entities at horizon level

  // Calculate size based on distance
  const scale = Math.min(3, (TILE * H * 0.4) / entity.dist);
  const spriteSize = TILE * scale * 0.8;

  if (spriteSize < 5) return; // Too small to draw

  // Check if blocked by wall
  const rayAngle = entity.angle;
  const ray = castRay(rayAngle);
  if (ray.dist < entity.dist - TILE * 0.5) return; // Behind wall

  // Draw entity
  if (entity.type === 'cop') {
    drawCopSprite(ctx, screenX, screenY + spriteSize * 0.3, spriteSize, 'front');

    // Draw chasing indicator
    if (entity.chasing) {
      ctx.font = `bold ${Math.max(12, spriteSize * 0.3)}px Nunito, sans-serif`;
      ctx.fillStyle = '#ff4444';
      ctx.textAlign = 'center';
      ctx.fillText('!', screenX, screenY - spriteSize * 0.4);
    }
  } else {
    drawCivilianSprite(ctx, screenX, screenY + spriteSize * 0.3, spriteSize, entity.variant);
  }
}

function drawExitSign() {
  // Calculate angle and distance to exit
  const dx = (exitTile.c + 0.5) * TILE - player.x;
  const dy = (exitTile.r + 0.5) * TILE - player.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const angle = Math.atan2(dy, dx);

  let relAngle = angle - player.angle;
  while (relAngle < -Math.PI) relAngle += Math.PI * 2;
  while (relAngle > Math.PI) relAngle -= Math.PI * 2;

  if (Math.abs(relAngle) > FOV / 2 + 0.3) return;
  if (dist > VIEW_DISTANCE * TILE) return;

  const screenX = W / 2 + (relAngle / (FOV / 2)) * (W / 2);
  const scale = Math.min(2, (TILE * H * 0.3) / dist);

  // Exit glow
  const glowSize = 60 * scale;
  const grad = ctx.createRadialGradient(screenX, H / 2, 0, screenX, H / 2, glowSize);
  grad.addColorStop(0, 'rgba(46, 213, 115, 0.6)');
  grad.addColorStop(0.5, 'rgba(46, 213, 115, 0.2)');
  grad.addColorStop(1, 'rgba(46, 213, 115, 0)');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(screenX, H / 2, glowSize, 0, Math.PI * 2);
  ctx.fill();

  // EXIT text
  ctx.font = `bold ${Math.max(14, 24 * scale)}px Nunito, sans-serif`;
  ctx.fillStyle = '#2ed573';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('EXIT', screenX, H / 2 - 30 * scale);
  ctx.fillText('üö™', screenX, H / 2 + 10 * scale);
}

function drawMinimap() {
  const mmScale = 4;
  const mmW = MALL_W * mmScale;
  const mmH = MALL_H * mmScale;
  const mmX = W - mmW - 15;
  const mmY = H - mmH - 180; // Above controls

  // Background
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillRect(mmX - 3, mmY - 3, mmW + 6, mmH + 6);

  // Tiles
  for (let r = 0; r < MALL_H; r++) {
    for (let c = 0; c < MALL_W; c++) {
      if (MALL[r][c] === 0) {
        const store = storeMap.get(`${r},${c}`);
        ctx.fillStyle = store ? store.color : '#3a3a5c';
      } else {
        ctx.fillStyle = '#aaa';
      }
      ctx.fillRect(mmX + c * mmScale, mmY + r * mmScale, mmScale, mmScale);
    }
  }

  // Exit
  ctx.fillStyle = '#2ed573';
  ctx.fillRect(mmX + exitTile.c * mmScale, mmY + exitTile.r * mmScale, mmScale, mmScale);

  // Start (jewelry)
  ctx.fillStyle = '#ffd700';
  ctx.fillRect(mmX + startTile.c * mmScale, mmY + startTile.r * mmScale, mmScale, mmScale);

  // Cops
  ctx.fillStyle = '#ff4444';
  for (const cop of cops) {
    const cr = Math.floor(cop.y / TILE);
    const cc = Math.floor(cop.x / TILE);
    ctx.fillRect(mmX + cc * mmScale, mmY + cr * mmScale, mmScale, mmScale);
  }

  // Player with direction indicator
  const pr = player.y / TILE;
  const pc = player.x / TILE;
  const px = mmX + pc * mmScale;
  const py = mmY + pr * mmScale;

  // Player dot
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(px, py, mmScale * 0.8, 0, Math.PI * 2);
  ctx.fill();

  // Direction indicator
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(px, py);
  ctx.lineTo(px + Math.cos(player.angle) * mmScale * 2, py + Math.sin(player.angle) * mmScale * 2);
  ctx.stroke();
}

function drawCompass() {
  // Calculate direction to exit
  const dx = (exitTile.c + 0.5) * TILE - player.x;
  const dy = (exitTile.r + 0.5) * TILE - player.y;
  const exitAngle = Math.atan2(dy, dx);

  let relAngle = exitAngle - player.angle;
  while (relAngle < -Math.PI) relAngle += Math.PI * 2;
  while (relAngle > Math.PI) relAngle -= Math.PI * 2;

  // Draw compass at top center
  const cx = W / 2;
  const cy = 50;
  const radius = 25;

  // Compass background
  ctx.fillStyle = 'rgba(0,0,0,0.5)';
  ctx.beginPath();
  ctx.arc(cx, cy, radius + 5, 0, Math.PI * 2);
  ctx.fill();

  // Arrow pointing to exit
  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(relAngle);

  ctx.fillStyle = '#2ed573';
  ctx.beginPath();
  ctx.moveTo(0, -radius);
  ctx.lineTo(-8, radius * 0.5);
  ctx.lineTo(8, radius * 0.5);
  ctx.closePath();
  ctx.fill();

  ctx.restore();

  // "EXIT" label
  ctx.font = 'bold 10px Nunito, sans-serif';
  ctx.fillStyle = '#2ed573';
  ctx.textAlign = 'center';
  ctx.fillText('EXIT', cx, cy + radius + 15);
}

function drawArrestBar() {
  const elapsed = Date.now() - arrestStartTime;
  const progress = Math.min(1, elapsed / ARREST_TIME);

  const barWidth = 200;
  const barHeight = 24;
  const barX = (W - barWidth) / 2;
  const barY = 100;

  // Background
  ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
  ctx.fillRect(barX - 5, barY - 25, barWidth + 10, barHeight + 35);

  // Warning text
  ctx.font = 'bold 14px Nunito, sans-serif';
  ctx.fillStyle = '#ff4444';
  ctx.textAlign = 'center';
  ctx.fillText('BEING ARRESTED! ESCAPE!', W / 2, barY - 5);

  // Bar background
  ctx.fillStyle = '#333';
  ctx.fillRect(barX, barY, barWidth, barHeight);

  // Progress bar (red, pulsing)
  const pulse = 0.7 + Math.sin(Date.now() * 0.01) * 0.3;
  ctx.fillStyle = `rgba(255, 68, 68, ${pulse})`;
  ctx.fillRect(barX, barY, barWidth * progress, barHeight);

  // Border
  ctx.strokeStyle = '#ff4444';
  ctx.lineWidth = 2;
  ctx.strokeRect(barX, barY, barWidth, barHeight);

  // Time remaining
  const remaining = Math.ceil((ARREST_TIME - elapsed) / 1000);
  ctx.font = 'bold 12px Nunito, sans-serif';
  ctx.fillStyle = '#fff';
  ctx.textAlign = 'center';
  ctx.fillText(`${remaining}s`, W / 2, barY + barHeight / 2 + 4);
}

// ===== GAME LOOP =====
function gameLoop() {
  if (!gameRunning) return;
  update();
  if (!gameRunning) return;
  render();
  animId = requestAnimationFrame(gameLoop);
}

// ===== END GAME =====
let gameEnded = false;

function endGame(won) {
  gameRunning = false;
  gameEnded = true;
  if (animId) cancelAnimationFrame(animId);

  const overlay = document.getElementById('endOverlay');
  const emoji = document.getElementById('endEmoji');
  const title = document.getElementById('endTitle');
  const msg = document.getElementById('endMsg');

  if (won) {
    emoji.textContent = 'üéâüíé';
    title.textContent = 'You Escaped!';
    msg.textContent = 'You got away with the jewelry!';
  } else {
    emoji.textContent = 'üöî';
    title.textContent = "Busted!";
    msg.textContent = 'The mall cops got you!';
  }

  overlay.classList.add('visible');
}

// Handle Enter key to restart when game has ended
document.addEventListener('keydown', e => {
  if (e.key === 'Enter' && gameEnded) {
    e.preventDefault();
    restartGame();
  }
});

function restartGame() {
  document.getElementById('endOverlay').classList.remove('visible');
  document.getElementById('gameArea').classList.add('hidden');
  document.getElementById('hud').classList.add('hidden');
  document.getElementById('mobileControls').classList.remove('visible');

  keys.forward = keys.backward = keys.turnLeft = keys.turnRight = false;

  // Reset arrest state
  beingArrested = false;
  arrestStartTime = null;
  gameEnded = false;

  document.getElementById('selectScreen').classList.remove('hidden');
}
</script>
</body>
</html>
