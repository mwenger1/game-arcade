<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Marshmallow Roaster</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Lilita+One&family=Nunito:wght@600;700;800;900&display=swap" rel="stylesheet">
<link rel="stylesheet" href="../shared/controls-modal.css">
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --night-top: #0a0a1a;
    --night-mid: #1a1a3e;
    --night-bot: #2d1b4e;
    --fire-orange: #ff9f43;
    --fire-red: #ff6b6b;
    --fire-yellow: #ffeaa7;
    --accent-brown: #8b4513;
    --accent-cream: #f5deb3;
    --card-bg: rgba(255,255,255,0.08);
    --card-border: rgba(255,255,255,0.12);
  }

  html, body { height: 100%; overflow: hidden; }

  body {
    font-family: 'Nunito', sans-serif;
    background: var(--night-top);
    color: #fff;
    -webkit-tap-highlight-color: transparent;
    touch-action: none;
    overscroll-behavior: none;
  }

  /* =========== SCREENS =========== */
  .screen {
    position: fixed;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 50;
    transition: opacity 0.35s, transform 0.35s;
    padding: 1.5rem;
  }
  .screen.hidden {
    opacity: 0;
    pointer-events: none;
    transform: scale(0.95);
  }

  .menu-bg {
    background: linear-gradient(170deg, #0a0a1a 0%, #1a1040 40%, #2d1b4e 100%);
  }

  .screen h1 {
    font-family: 'Lilita One', cursive;
    font-size: clamp(1.8rem, 7vw, 2.8rem);
    margin-bottom: 0.3rem;
    text-align: center;
  }
  .screen h1 .gradient-text {
    background: linear-gradient(135deg, #ff9f43, #ffeaa7, #ff6b6b);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .screen .subtitle {
    color: rgba(255,255,255,0.5);
    font-weight: 700;
    font-size: 0.9rem;
    margin-bottom: 1.5rem;
    text-align: center;
  }

  .go-btn {
    font-family: 'Nunito', sans-serif;
    font-weight: 800;
    font-size: 1.15rem;
    padding: 0.9rem 3rem;
    background: linear-gradient(135deg, var(--fire-orange), var(--fire-yellow));
    color: #2d1b4e;
    border: none;
    border-radius: 1.2rem;
    cursor: pointer;
    margin-top: 0.5rem;
    transition: transform 0.15s, filter 0.15s;
    letter-spacing: 0.5px;
  }
  .go-btn:active { transform: scale(0.95); filter: brightness(1.1); }

  .back-link {
    position: absolute;
    top: 1rem; left: 1rem;
    display: flex; align-items: center; gap: 0.3rem;
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.12);
    color: #ccc;
    font-family: 'Nunito', sans-serif;
    font-weight: 700;
    font-size: 0.85rem;
    padding: 0.45rem 0.9rem;
    border-radius: 2rem;
    cursor: pointer;
    text-decoration: none;
    transition: background 0.2s;
    z-index: 60;
  }
  .back-link:hover { background: rgba(255,255,255,0.14); color: #fff; }

  /* Menu campfire decoration */
  .campfire-deco {
    font-size: 4rem;
    margin-bottom: 0.5rem;
    animation: fireGlow 1s ease-in-out infinite alternate;
  }
  @keyframes fireGlow {
    0% { filter: drop-shadow(0 0 10px #ff6b00) drop-shadow(0 0 20px #ff9f43); transform: scale(1); }
    100% { filter: drop-shadow(0 0 15px #ff6b00) drop-shadow(0 0 30px #ff9f43); transform: scale(1.05); }
  }

  /* =========== GAME CANVAS =========== */
  #gameCanvas {
    position: fixed;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 1;
  }

  /* HUD */
  .hud {
    position: fixed;
    top: 0; left: 0; right: 0;
    z-index: 40;
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    padding: 0.8rem 1rem;
    pointer-events: none;
  }
  .hud.hidden { display: none; }

  .hud-item {
    background: rgba(0,0,0,0.45);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    padding: 0.5rem 0.9rem;
    border-radius: 1rem;
    pointer-events: auto;
  }
  .hud-label {
    font-size: 0.6rem;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: rgba(255,255,255,0.5);
    font-weight: 700;
  }
  .hud-value {
    font-family: 'Lilita One', cursive;
    font-size: 1.3rem;
    color: #fff;
  }
  .hud-value.golden { color: #ffd700; }
  .hud-value.burning { color: #ff4444; }

  .hud-menu-btn {
    background: rgba(0,0,0,0.45);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    padding: 0.5rem 0.9rem;
    border-radius: 1rem;
    border: none;
    color: #ccc;
    font-family: 'Nunito', sans-serif;
    font-weight: 700;
    font-size: 0.8rem;
    cursor: pointer;
    pointer-events: auto;
  }

  /* Mobile controls */
  .mobile-controls {
    position: fixed;
    bottom: 0;
    left: 0; right: 0;
    z-index: 40;
    display: none;
    padding: 1.5rem 1.5rem 2rem;
    justify-content: space-between;
    align-items: flex-end;
    pointer-events: none;
  }
  .mobile-controls.visible { display: flex; }

  .ctrl-btn {
    width: 80px; height: 80px;
    background: rgba(0,0,0,0.6);
    border: 3px solid rgba(255,159,67,0.9);
    border-radius: 1rem;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 2px;
    color: rgb(255,200,100);
    cursor: pointer;
    user-select: none;
    -webkit-user-select: none;
    transition: background 0.1s, transform 0.1s;
    pointer-events: auto;
    box-shadow: 0 4px 15px rgba(0,0,0,0.4);
  }
  .ctrl-btn:active, .ctrl-btn.pressed {
    background: rgba(255,159,67,0.4);
    transform: scale(0.95);
  }
  .ctrl-arrow {
    font-size: 1.6rem;
    line-height: 1;
  }
  .ctrl-label {
    font-size: 0.65rem;
    font-weight: 800;
    letter-spacing: 1px;
    opacity: 0.8;
  }

  /* Result overlay */
  .result-overlay {
    position: fixed;
    inset: 0;
    z-index: 80;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.7);
    backdrop-filter: blur(4px);
    -webkit-backdrop-filter: blur(4px);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s;
    padding: 1.5rem;
  }
  .result-overlay.visible {
    opacity: 1;
    pointer-events: auto;
  }
  .result-card {
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 1.4rem;
    padding: 2rem 1.5rem;
    text-align: center;
    max-width: 340px;
    width: 100%;
  }
  .result-emoji { font-size: 4rem; margin-bottom: 0.5rem; }
  .result-title {
    font-family: 'Lilita One', cursive;
    font-size: 1.6rem;
    margin-bottom: 0.3rem;
  }
  .result-score { color: rgba(255,255,255,0.7); font-weight: 700; margin-bottom: 0.3rem; }
  .result-best { color: var(--fire-orange); font-weight: 800; font-size: 0.85rem; margin-bottom: 1rem; }
  .result-btns { display: flex; flex-direction: column; gap: 0.5rem; }
  .result-btn {
    font-family: 'Nunito', sans-serif;
    font-weight: 800;
    font-size: 1rem;
    padding: 0.8rem;
    border: none;
    border-radius: 1rem;
    cursor: pointer;
    transition: transform 0.15s;
    text-decoration: none;
    text-align: center;
    display: block;
  }
  .result-btn:active { transform: scale(0.96); }
  .result-primary {
    background: linear-gradient(135deg, var(--fire-orange), var(--fire-yellow));
    color: #2d1b4e;
  }
  .result-secondary {
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.12);
    color: #ccc;
  }

  /* Stars background for menu */
  .stars {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 0;
    overflow: hidden;
  }
  .star {
    position: absolute;
    width: 3px; height: 3px;
    background: #fff;
    border-radius: 50%;
    animation: twinkle var(--dur, 3s) ease-in-out infinite alternate;
    opacity: 0;
  }
  @keyframes twinkle {
    0% { opacity: 0.1; transform: scale(0.8); }
    100% { opacity: var(--max-o, 0.8); transform: scale(1.2); }
  }

  /* Firefly particles for menu */
  .firefly {
    position: absolute;
    width: 4px; height: 4px;
    background: #ffd700;
    border-radius: 50%;
    animation: fireflyFloat 8s ease-in-out infinite;
    opacity: 0;
    box-shadow: 0 0 6px #ffd700, 0 0 12px #ff9f43;
  }
  @keyframes fireflyFloat {
    0%, 100% { opacity: 0; transform: translate(0, 0); }
    25% { opacity: 0.8; transform: translate(var(--dx, 20px), var(--dy, -30px)); }
    50% { opacity: 0.4; transform: translate(calc(var(--dx, 20px) * 1.5), calc(var(--dy, -30px) * 0.5)); }
    75% { opacity: 0.7; transform: translate(var(--dx, 20px), var(--dy, -30px)); }
  }
</style>
</head>
<body>

<div class="stars" id="stars"></div>
<canvas id="gameCanvas"></canvas>

<!-- ===== START SCREEN ===== -->
<div class="screen menu-bg" id="startScreen">
  <a href="../index.html" class="back-link">‚Äπ Home</a>

  <div class="campfire-deco">üèïÔ∏è</div>
  <h1><span class="gradient-text">Marshmallow Roaster</span></h1>
  <p class="subtitle">Roast the perfect golden marshmallow!</p>

  <button class="go-btn" onclick="startGame()">Start Roasting!</button>
</div>

<!-- ===== HUD ===== -->
<div class="hud hidden" id="hud">
  <div class="hud-item">
    <div class="hud-label">Score</div>
    <div class="hud-value" id="hudScore">0</div>
  </div>
  <div class="hud-item">
    <div class="hud-label">Status</div>
    <div class="hud-value" id="hudStatus">Raw</div>
  </div>
  <button class="hud-menu-btn" onclick="backToMenu()">‚úï</button>
</div>

<!-- ===== MOBILE CONTROLS ===== -->
<div class="mobile-controls" id="mobileControls">
  <button class="ctrl-btn" id="btnUp"><span class="ctrl-arrow">‚ñ≤</span><span class="ctrl-label">UP</span></button>
  <button class="ctrl-btn" id="btnDown"><span class="ctrl-arrow">‚ñº</span><span class="ctrl-label">DOWN</span></button>
</div>

<!-- ===== CONTROLS MODAL ===== -->
<div class="controls-overlay" id="controlsOverlay">
  <div class="controls-card">
    <h2>How to Roast</h2>
    <div class="controls-row">
      <div class="key-icon">‚ñ≤</div>
      <div class="key-icon">‚ñº</div>
      <div class="key-desc">Move marshmallow up & down</div>
    </div>
    <div class="controls-row">
      <div class="key-icon" style="width: auto; padding: 0 12px;">üéØ</div>
      <div class="key-desc">Roast in the green zone until golden</div>
    </div>
    <div class="controls-row">
      <div class="key-icon" style="width: auto; padding: 0 12px;">‚ú®</div>
      <div class="key-desc">When ready, pull UP to make s'more!</div>
    </div>
    <div class="controls-row">
      <div class="key-icon" style="width: auto; padding: 0 12px;">‚ö†Ô∏è</div>
      <div class="key-desc">Don't let it burn!</div>
    </div>
    <button class="controls-go-btn" onclick="dismissControls()">Let's Roast!</button>
  </div>
</div>

<!-- ===== RESULT OVERLAY ===== -->
<div class="result-overlay" id="resultOverlay">
  <div class="result-card">
    <div class="result-emoji" id="resultEmoji">üç°</div>
    <div class="result-title" id="resultTitle">Perfect S'more!</div>
    <div class="result-score" id="resultScore">Score: 0</div>
    <div class="result-best" id="resultBest">Best: 0</div>
    <div class="result-btns">
      <button class="result-btn result-primary" onclick="restartGame()">Roast Another!</button>
      <a href="../index.html" class="result-btn result-secondary">Back to Home</a>
    </div>
  </div>
</div>

<script>
// ==================== SETUP ====================

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let W, H;
function resizeCanvas() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Detect mobile
const isMobile = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;

// Best score
let bestScore = parseInt(localStorage.getItem('marshmallowBest') || '0', 10);

// ==================== GAME STATE ====================

let game = null;
let animId = null;
let gameRunning = false;
let shownControls = false;

// Input state
const keys = { up: false, down: false };

// Marshmallow states
const MALLOW_RAW = 0;
const MALLOW_TOASTING = 1;
const MALLOW_BURNING = 2;
const MALLOW_BURNT = 3;

// ==================== AUDIO CONTEXT ====================

let audioCtx = null;
let masterGain = null;
let crackleInterval = null;

function initAudio() {
  if (audioCtx) return;
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    // Master gain for all fire sounds
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.3;
    masterGain.connect(audioCtx.destination);

    // Create base fire rumble (low frequency noise)
    createFireBase();

    // Start crackling sounds at random intervals
    scheduleCrackle();

  } catch (e) {
    // Audio not supported
  }
}

function createFireBase() {
  // Low rumbling base of the fire - brown noise (filtered)
  const bufferSize = audioCtx.sampleRate * 3;
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);

  // Generate brown noise (integrated white noise)
  let lastOut = 0;
  for (let i = 0; i < bufferSize; i++) {
    const white = Math.random() * 2 - 1;
    data[i] = (lastOut + (0.02 * white)) / 1.02;
    lastOut = data[i];
    data[i] *= 3.5; // Amplify
  }

  const baseNoise = audioCtx.createBufferSource();
  baseNoise.buffer = buffer;
  baseNoise.loop = true;

  // Low pass filter for deep rumble
  const lowPass = audioCtx.createBiquadFilter();
  lowPass.type = 'lowpass';
  lowPass.frequency.value = 150;
  lowPass.Q.value = 1;

  // Gentle modulation for wavering effect
  const baseGain = audioCtx.createGain();
  baseGain.gain.value = 0.4;

  baseNoise.connect(lowPass);
  lowPass.connect(baseGain);
  baseGain.connect(masterGain);
  baseNoise.start();
}

function createCrackle() {
  // Individual crackle/pop sound
  const duration = 0.03 + Math.random() * 0.08;
  const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * duration, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);

  // Sharp attack, quick decay - like wood popping
  for (let i = 0; i < buffer.length; i++) {
    const t = i / buffer.length;
    // Envelope: sharp attack, exponential decay
    const envelope = Math.exp(-t * 15) * (1 - Math.exp(-t * 500));
    // Mix of noise frequencies for realistic crackle
    const noise = (Math.random() * 2 - 1);
    data[i] = noise * envelope;
  }

  const crackle = audioCtx.createBufferSource();
  crackle.buffer = buffer;

  // Bandpass filter for woody crackle sound
  const bandpass = audioCtx.createBiquadFilter();
  bandpass.type = 'bandpass';
  bandpass.frequency.value = 800 + Math.random() * 2000;
  bandpass.Q.value = 1 + Math.random() * 2;

  // Random volume for variety
  const gain = audioCtx.createGain();
  gain.gain.value = 0.3 + Math.random() * 0.7;

  // Slight pan for spatial effect
  const panner = audioCtx.createStereoPanner();
  panner.pan.value = (Math.random() - 0.5) * 0.6;

  crackle.connect(bandpass);
  bandpass.connect(gain);
  gain.connect(panner);
  panner.connect(masterGain);
  crackle.start();
}

function createPop() {
  // Louder pop sound (like sap popping)
  const duration = 0.05 + Math.random() * 0.05;
  const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * duration, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);

  for (let i = 0; i < buffer.length; i++) {
    const t = i / buffer.length;
    // Very sharp attack
    const envelope = Math.exp(-t * 25) * (1 - Math.exp(-t * 1000));
    data[i] = (Math.random() * 2 - 1) * envelope;
  }

  const pop = audioCtx.createBufferSource();
  pop.buffer = buffer;

  // Higher frequency for pop
  const highpass = audioCtx.createBiquadFilter();
  highpass.type = 'highpass';
  highpass.frequency.value = 500;

  const gain = audioCtx.createGain();
  gain.gain.value = 0.5 + Math.random() * 0.5;

  const panner = audioCtx.createStereoPanner();
  panner.pan.value = (Math.random() - 0.5) * 0.8;

  pop.connect(highpass);
  highpass.connect(gain);
  gain.connect(panner);
  panner.connect(masterGain);
  pop.start();
}

function scheduleCrackle() {
  if (!audioCtx) return;

  // Random crackles
  const crackleDelay = 50 + Math.random() * 200;
  setTimeout(() => {
    if (audioCtx && audioCtx.state === 'running') {
      createCrackle();

      // Occasionally do multiple quick crackles (like a burst)
      if (Math.random() < 0.3) {
        setTimeout(() => createCrackle(), 20 + Math.random() * 40);
      }
      if (Math.random() < 0.15) {
        setTimeout(() => createCrackle(), 50 + Math.random() * 50);
      }

      // Occasional louder pop
      if (Math.random() < 0.1) {
        setTimeout(() => createPop(), Math.random() * 100);
      }
    }
    scheduleCrackle();
  }, crackleDelay);
}

// ==================== GAME INIT ====================

function initGame() {
  // Stick properties - fixed length, hand moves up/down
  const stickLength = Math.min(W, H) * 0.5; // Fixed length
  const stickAngle = 0.25; // Consistent downward angle toward fire (radians)

  // Hand position (left end of stick) - moves vertically
  const handX = W * 0.12;
  const handMinY = H * 0.05;  // Can raise high above fire
  const handMaxY = H * 0.72;  // Can lower into the fire
  const handStartY = H * 0.35;

  // Calculate initial marshmallow position
  const initialMallowX = handX + Math.cos(stickAngle) * stickLength;
  const initialMallowY = handStartY + Math.sin(stickAngle) * stickLength;

  game = {
    // Stick - fixed length and angle, hand moves up/down
    stickLength: stickLength,
    stickAngle: stickAngle,
    handX: handX,
    handY: handStartY,
    handMinY: handMinY,
    handMaxY: handMaxY,
    handSpeed: 2.5,

    // Marshmallow position (calculated from hand + stick)
    mallowX: initialMallowX,
    mallowY: initialMallowY,
    mallowRotation: 0,
    mallowRotationSpeed: 0.02,

    // Fire
    fireBaseY: H * 0.78,
    fireHeight: H * 0.18,
    fireOffset: 0, // Oscillating fire height
    firePhase: 0,
    fireSpeed: 0.015, // How fast fire oscillates
    fireAmplitude: H * 0.08, // How much fire moves

    // Zones
    perfectZoneTop: 0,
    perfectZoneBottom: 0,
    burnZoneTop: 0,

    // Roasting state
    roastLevel: 0, // 0-40 raw, 40-65 toasting, 65-85 golden, 85-105 perfect, 105+ overdone
    mallowState: MALLOW_RAW,
    mallowOnFire: false,
    fireTimer: 0, // How long on fire
    canFinish: false, // True when roast level is in "done" range (65+)
    finishZoneTimer: 0, // Time spent in finish zone while canFinish is true

    // Score
    score: 0,
    scoreMultiplier: 1,
    perfectTime: 0, // Time spent in perfect zone

    // Difficulty
    level: 1,
    levelTimer: 0,

    // Visual effects
    fireParticles: [],
    smokeParticles: [],
    sparkParticles: [],
    mallowGlow: 0,

    // Game state
    gameOver: false,
    gameOverTimer: 0,

    frameCount: 0,
  };

  // Pre-fill particles
  for (let i = 0; i < 40; i++) {
    game.fireParticles.push(createFireParticle());
  }
  for (let i = 0; i < 15; i++) {
    game.smokeParticles.push(createSmokeParticle());
  }

  updateZones();
}

function updateZones() {
  // Calculate current fire top position
  const fireTop = game.fireBaseY - game.fireHeight + game.fireOffset;

  // Perfect zone is just above the flame tips - made larger for easier gameplay
  game.perfectZoneBottom = fireTop - 5;
  game.perfectZoneTop = fireTop - H * 0.18;

  // Burn zone is in/near the flames
  game.burnZoneTop = fireTop + H * 0.03;
}

// ==================== PARTICLE SYSTEMS ====================

function createFireParticle() {
  const fireWidth = W * 0.2;
  return {
    x: W * 0.5 + (Math.random() - 0.5) * fireWidth,
    y: game ? game.fireBaseY : H * 0.78,
    vx: (Math.random() - 0.5) * 1,
    vy: -2 - Math.random() * 3,
    life: 40 + Math.random() * 30,
    maxLife: 40 + Math.random() * 30,
    size: 8 + Math.random() * 15,
    hue: Math.random() < 0.3 ? 50 : (Math.random() < 0.5 ? 30 : 15), // yellow, orange, red
  };
}

function createSmokeParticle() {
  return {
    x: W * 0.5 + (Math.random() - 0.5) * 40,
    y: game ? (game.fireBaseY - game.fireHeight - 20) : H * 0.58,
    vx: (Math.random() - 0.5) * 0.5,
    vy: -0.5 - Math.random() * 1,
    life: 80 + Math.random() * 60,
    maxLife: 80 + Math.random() * 60,
    size: 15 + Math.random() * 20,
    opacity: 0.1 + Math.random() * 0.15,
  };
}

function createSparkParticle(x, y) {
  return {
    x: x,
    y: y,
    vx: (Math.random() - 0.5) * 4,
    vy: -3 - Math.random() * 4,
    life: 20 + Math.random() * 20,
    maxLife: 20 + Math.random() * 20,
    size: 2 + Math.random() * 3,
  };
}

// ==================== DRAWING ====================

function drawBackground() {
  // Night sky gradient
  const skyGrad = ctx.createLinearGradient(0, 0, 0, H);
  skyGrad.addColorStop(0, '#0a0a1a');
  skyGrad.addColorStop(0.4, '#1a1040');
  skyGrad.addColorStop(0.7, '#2d1b4e');
  skyGrad.addColorStop(1, '#1a1a2e');
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, W, H);

  // Stars
  ctx.fillStyle = '#fff';
  for (let i = 0; i < 50; i++) {
    const x = (i * 137.5) % W;
    const y = (i * 89.3) % (H * 0.5);
    const twinkle = Math.sin(game.frameCount * 0.03 + i) * 0.5 + 0.5;
    ctx.globalAlpha = 0.3 + twinkle * 0.5;
    ctx.beginPath();
    ctx.arc(x, y, 1 + Math.random(), 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // Moon
  ctx.fillStyle = '#f5f5dc';
  ctx.beginPath();
  ctx.arc(W * 0.85, H * 0.12, 25, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#e8e8c8';
  ctx.beginPath();
  ctx.arc(W * 0.85 - 3, H * 0.12 + 2, 4, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(W * 0.85 + 5, H * 0.12 - 5, 3, 0, Math.PI * 2);
  ctx.fill();

  // Distant treeline
  ctx.fillStyle = '#0d1117';
  for (let x = 0; x < W + 40; x += 35) {
    const treeH = 50 + Math.sin(x * 0.1) * 20;
    const baseY = H * 0.55;
    ctx.beginPath();
    ctx.moveTo(x - 18, baseY);
    ctx.lineTo(x, baseY - treeH);
    ctx.lineTo(x + 18, baseY);
    ctx.fill();
  }

  // Ground
  const groundGrad = ctx.createLinearGradient(0, H * 0.55, 0, H);
  groundGrad.addColorStop(0, '#1a2f1a');
  groundGrad.addColorStop(0.3, '#1a3520');
  groundGrad.addColorStop(1, '#0d1f0d');
  ctx.fillStyle = groundGrad;
  ctx.fillRect(0, H * 0.55, W, H * 0.45);

  // Grass tufts near fire
  ctx.fillStyle = '#2d4a2d';
  for (let i = 0; i < 20; i++) {
    const gx = i * (W / 20) + 10;
    const gy = H * 0.85 + Math.sin(i * 1.5) * 8;
    ctx.beginPath();
    ctx.moveTo(gx - 5, gy);
    ctx.quadraticCurveTo(gx - 2, gy - 12, gx, gy);
    ctx.quadraticCurveTo(gx + 2, gy - 14, gx + 4, gy);
    ctx.fill();
  }
}

function drawStump() {
  // S'mores ingredients stump (right side)
  const stumpX = W * 0.78;
  const stumpY = H * 0.72;

  // Fire glow on stump
  const glowIntensity = 0.15 + Math.sin(game.frameCount * 0.1) * 0.05;
  ctx.fillStyle = `rgba(255, 150, 50, ${glowIntensity})`;
  ctx.beginPath();
  ctx.ellipse(stumpX, stumpY + 10, 50, 20, 0, 0, Math.PI * 2);
  ctx.fill();

  // Stump body
  ctx.fillStyle = '#4a3728';
  ctx.beginPath();
  ctx.ellipse(stumpX, stumpY + 25, 35, 12, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillRect(stumpX - 35, stumpY - 15, 70, 40);

  // Stump top
  ctx.fillStyle = '#5a4738';
  ctx.beginPath();
  ctx.ellipse(stumpX, stumpY - 15, 35, 12, 0, 0, Math.PI * 2);
  ctx.fill();

  // Wood rings
  ctx.strokeStyle = '#6a5748';
  ctx.lineWidth = 1;
  for (let r = 10; r < 30; r += 8) {
    ctx.beginPath();
    ctx.ellipse(stumpX, stumpY - 15, r, r * 0.35, 0, 0, Math.PI * 2);
    ctx.stroke();
  }

  // Graham crackers (stacked)
  ctx.fillStyle = '#d4a76a';
  ctx.fillRect(stumpX - 18, stumpY - 28, 22, 4);
  ctx.fillRect(stumpX - 16, stumpY - 33, 22, 4);
  // Cracker texture
  ctx.fillStyle = '#c49a5a';
  for (let i = 0; i < 3; i++) {
    ctx.fillRect(stumpX - 15 + i * 7, stumpY - 27, 1, 2);
    ctx.fillRect(stumpX - 13 + i * 7, stumpY - 32, 1, 2);
  }

  // Chocolate squares
  ctx.fillStyle = '#3d2314';
  ctx.fillRect(stumpX + 5, stumpY - 30, 16, 10);
  ctx.fillRect(stumpX + 8, stumpY - 32, 16, 10);
  // Chocolate segments
  ctx.strokeStyle = '#2d1810';
  ctx.lineWidth = 0.5;
  ctx.beginPath();
  ctx.moveTo(stumpX + 13, stumpY - 30);
  ctx.lineTo(stumpX + 13, stumpY - 20);
  ctx.moveTo(stumpX + 16, stumpY - 32);
  ctx.lineTo(stumpX + 16, stumpY - 22);
  ctx.stroke();
}

function drawFirePit() {
  const fireX = W * 0.5;
  const fireY = game.fireBaseY;

  // Fire glow on ground
  const glowRadius = 120 + Math.sin(game.frameCount * 0.15) * 20;
  const glowGrad = ctx.createRadialGradient(fireX, fireY, 0, fireX, fireY, glowRadius);
  glowGrad.addColorStop(0, 'rgba(255, 150, 50, 0.4)');
  glowGrad.addColorStop(0.5, 'rgba(255, 100, 30, 0.15)');
  glowGrad.addColorStop(1, 'rgba(255, 50, 0, 0)');
  ctx.fillStyle = glowGrad;
  ctx.fillRect(fireX - glowRadius, fireY - glowRadius * 0.5, glowRadius * 2, glowRadius);

  // Stone ring
  ctx.fillStyle = '#4a4a4a';
  const stoneCount = 12;
  for (let i = 0; i < stoneCount; i++) {
    const angle = (i / stoneCount) * Math.PI * 2;
    const sx = fireX + Math.cos(angle) * 55;
    const sy = fireY + Math.sin(angle) * 18 + 5;
    const sw = 18 + Math.sin(i * 2) * 4;
    const sh = 12 + Math.cos(i * 3) * 3;

    // Stone shadow
    ctx.fillStyle = '#2a2a2a';
    ctx.beginPath();
    ctx.ellipse(sx + 2, sy + 2, sw / 2, sh / 2, angle * 0.2, 0, Math.PI * 2);
    ctx.fill();

    // Stone
    ctx.fillStyle = '#5a5a5a';
    ctx.beginPath();
    ctx.ellipse(sx, sy, sw / 2, sh / 2, angle * 0.2, 0, Math.PI * 2);
    ctx.fill();

    // Stone highlight
    ctx.fillStyle = `rgba(255, 150, 80, ${0.1 + Math.sin(game.frameCount * 0.1 + i) * 0.05})`;
    ctx.beginPath();
    ctx.ellipse(sx, sy, sw / 2, sh / 2, angle * 0.2, 0, Math.PI * 2);
    ctx.fill();
  }

  // Logs
  ctx.fillStyle = '#3d2817';
  // Log 1
  ctx.save();
  ctx.translate(fireX - 25, fireY);
  ctx.rotate(-0.3);
  ctx.beginPath();
  ctx.roundRect(-25, -6, 50, 12, 4);
  ctx.fill();
  ctx.restore();
  // Log 2
  ctx.save();
  ctx.translate(fireX + 25, fireY);
  ctx.rotate(0.3);
  ctx.beginPath();
  ctx.roundRect(-25, -6, 50, 12, 4);
  ctx.fill();
  ctx.restore();
  // Log ends (glowing)
  const logGlow = 0.3 + Math.sin(game.frameCount * 0.2) * 0.2;
  ctx.fillStyle = `rgba(255, 100, 0, ${logGlow})`;
  ctx.beginPath();
  ctx.arc(fireX - 45, fireY - 3, 6, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(fireX + 45, fireY - 3, 6, 0, Math.PI * 2);
  ctx.fill();
}

function drawFire() {
  const fireX = W * 0.5;
  const fireY = game.fireBaseY;
  const fireTop = fireY - game.fireHeight + game.fireOffset;

  // Update and draw fire particles
  game.fireParticles.forEach((p, i) => {
    p.x += p.vx + Math.sin(game.frameCount * 0.1 + i) * 0.5;
    p.y += p.vy;
    p.life--;
    p.size *= 0.97;

    if (p.life <= 0 || p.size < 2) {
      Object.assign(p, createFireParticle());
      p.y = fireY;
    }

    const alpha = (p.life / p.maxLife) * 0.9;
    const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
    gradient.addColorStop(0, `hsla(${p.hue}, 100%, 60%, ${alpha})`);
    gradient.addColorStop(0.4, `hsla(${p.hue - 10}, 100%, 50%, ${alpha * 0.7})`);
    gradient.addColorStop(1, `hsla(${p.hue - 20}, 100%, 30%, 0)`);

    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
  });

  // Main flame shape
  const flameGrad = ctx.createLinearGradient(fireX, fireY, fireX, fireTop);
  flameGrad.addColorStop(0, 'rgba(255, 100, 0, 0.9)');
  flameGrad.addColorStop(0.3, 'rgba(255, 150, 0, 0.8)');
  flameGrad.addColorStop(0.6, 'rgba(255, 200, 50, 0.6)');
  flameGrad.addColorStop(1, 'rgba(255, 255, 100, 0)');

  ctx.fillStyle = flameGrad;
  ctx.beginPath();
  const waveOffset = Math.sin(game.frameCount * 0.15) * 8;
  ctx.moveTo(fireX - 40, fireY);
  ctx.quadraticCurveTo(fireX - 30 + waveOffset, fireY - game.fireHeight * 0.5, fireX - 10, fireTop + 20);
  ctx.quadraticCurveTo(fireX + waveOffset * 0.5, fireTop - 10, fireX + 10, fireTop + 20);
  ctx.quadraticCurveTo(fireX + 30 - waveOffset, fireY - game.fireHeight * 0.5, fireX + 40, fireY);
  ctx.fill();

  // Inner bright core
  const coreGrad = ctx.createLinearGradient(fireX, fireY - 10, fireX, fireTop + 30);
  coreGrad.addColorStop(0, 'rgba(255, 255, 200, 0.8)');
  coreGrad.addColorStop(0.5, 'rgba(255, 220, 100, 0.5)');
  coreGrad.addColorStop(1, 'rgba(255, 180, 50, 0)');

  ctx.fillStyle = coreGrad;
  ctx.beginPath();
  ctx.moveTo(fireX - 20, fireY - 10);
  ctx.quadraticCurveTo(fireX + waveOffset * 0.3, fireTop + 40, fireX + 20, fireY - 10);
  ctx.fill();
}

function drawSmoke() {
  game.smokeParticles.forEach((p, i) => {
    p.x += p.vx + Math.sin(game.frameCount * 0.02 + i) * 0.3;
    p.y += p.vy;
    p.life--;
    p.size += 0.2;

    if (p.life <= 0) {
      Object.assign(p, createSmokeParticle());
    }

    const alpha = (p.life / p.maxLife) * p.opacity;
    ctx.fillStyle = `rgba(100, 100, 120, ${alpha})`;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
  });
}

function drawStick() {
  // Hand position (left end) and stick properties
  const handX = game.handX;
  const handY = game.handY;
  const length = game.stickLength;
  const angle = game.stickAngle;

  // Calculate end point (where marshmallow attaches)
  const endX = handX + Math.cos(angle) * length;
  const endY = handY + Math.sin(angle) * length;

  // Store for marshmallow drawing
  game.mallowX = endX;
  game.mallowY = endY;

  // Natural stick has slight bend due to weight - more bend when lower
  const bendAmount = 15;

  // Control points for natural curved stick shape
  const ctrl1X = handX + Math.cos(angle) * length * 0.33;
  const ctrl1Y = handY + Math.sin(angle) * length * 0.33 + bendAmount * 0.5;
  const ctrl2X = handX + Math.cos(angle) * length * 0.66;
  const ctrl2Y = handY + Math.sin(angle) * length * 0.66 + bendAmount * 0.9;

  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';

  // Stick shadow
  ctx.strokeStyle = 'rgba(0,0,0,0.25)';
  ctx.lineWidth = 9;
  ctx.beginPath();
  ctx.moveTo(handX + 3, handY + 3);
  ctx.bezierCurveTo(ctrl1X + 3, ctrl1Y + 3, ctrl2X + 3, ctrl2Y + 3, endX + 3, endY + 3);
  ctx.stroke();

  // Main stick - dark bark base
  ctx.strokeStyle = '#3d2817';
  ctx.lineWidth = 8;
  ctx.beginPath();
  ctx.moveTo(handX, handY);
  ctx.bezierCurveTo(ctrl1X, ctrl1Y, ctrl2X, ctrl2Y, endX, endY);
  ctx.stroke();

  // Lighter wood layer with natural variation
  const woodGrad = ctx.createLinearGradient(handX, handY, endX, endY);
  woodGrad.addColorStop(0, '#6B5344');
  woodGrad.addColorStop(0.2, '#7a6350');
  woodGrad.addColorStop(0.4, '#5d4a3a');
  woodGrad.addColorStop(0.6, '#6B5344');
  woodGrad.addColorStop(0.8, '#54433a');
  woodGrad.addColorStop(1, '#4a3828');

  ctx.strokeStyle = woodGrad;
  ctx.lineWidth = 6;
  ctx.beginPath();
  ctx.moveTo(handX, handY);
  ctx.bezierCurveTo(ctrl1X, ctrl1Y, ctrl2X, ctrl2Y, endX, endY);
  ctx.stroke();

  // Bark texture - small dark lines along the stick
  ctx.strokeStyle = '#2d1810';
  ctx.lineWidth = 1;
  for (let i = 0; i < 7; i++) {
    const t = 0.12 + i * 0.12;
    // Interpolate along the bezier curve approximately
    const px = handX + (endX - handX) * t;
    const py = handY + (endY - handY) * t + bendAmount * t * (1 - t) * 4;

    // Small bark marks perpendicular to stick
    const markAngle = angle + Math.PI / 2 + (Math.sin(i * 3.7) * 0.3);
    const markLen = 2 + Math.sin(i * 5.1) * 1.5;

    ctx.beginPath();
    ctx.moveTo(px - Math.cos(markAngle) * markLen, py - Math.sin(markAngle) * markLen);
    ctx.lineTo(px + Math.cos(markAngle) * markLen, py + Math.sin(markAngle) * markLen);
    ctx.stroke();
  }

  // Knots for natural wood look
  ctx.fillStyle = '#2d1810';
  const knot1T = 0.28;
  const knot1X = handX + (endX - handX) * knot1T;
  const knot1Y = handY + (endY - handY) * knot1T + bendAmount * knot1T * (1 - knot1T) * 4;
  ctx.beginPath();
  ctx.ellipse(knot1X, knot1Y + 1, 3, 2, angle, 0, Math.PI * 2);
  ctx.fill();

  const knot2T = 0.58;
  const knot2X = handX + (endX - handX) * knot2T;
  const knot2Y = handY + (endY - handY) * knot2T + bendAmount * knot2T * (1 - knot2T) * 4;
  ctx.beginPath();
  ctx.ellipse(knot2X, knot2Y - 1, 2, 1.5, angle + 0.2, 0, Math.PI * 2);
  ctx.fill();

  // Top highlight for 3D effect
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(handX, handY - 2);
  ctx.bezierCurveTo(ctrl1X, ctrl1Y - 2, ctrl2X, ctrl2Y - 2, endX, endY - 2);
  ctx.stroke();

  // Fire glow on stick near the marshmallow end
  const glowIntensity = 0.15 + Math.sin(game.frameCount * 0.1) * 0.05;
  const glowT = 0.85;
  const glowX = handX + (endX - handX) * glowT;
  const glowY = handY + (endY - handY) * glowT + bendAmount * glowT * (1 - glowT) * 4;

  const fireGlow = ctx.createRadialGradient(glowX, glowY + 15, 0, glowX, glowY + 15, 35);
  fireGlow.addColorStop(0, `rgba(255, 150, 50, ${glowIntensity})`);
  fireGlow.addColorStop(1, 'rgba(255, 100, 30, 0)');
  ctx.fillStyle = fireGlow;
  ctx.fillRect(glowX - 40, glowY - 20, 80, 70);
}

function drawMarshmallow() {
  const x = game.mallowX;
  const y = game.mallowY;
  const rotation = game.mallowRotation;

  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(rotation);

  // Size varies slightly with roast
  const baseSize = 22;
  const size = baseSize + (game.roastLevel > 100 ? (game.roastLevel - 100) * 0.05 : 0);

  // Marshmallow dimensions - wider than tall like a real cylindrical marshmallow
  const mw = size * 1.1;   // half-width
  const mh = size * 0.75;  // half-height
  const cornerR = Math.min(mw, mh) * 0.45;

  // Determine color based on roast level
  // Perfect zone is 80-100, should be beautiful golden brown
  let baseColor, shadowColor, highlightColor;

  if (game.roastLevel < 15) {
    // Raw - pure white marshmallow
    baseColor = '#f8f8f8';
    shadowColor = '#e8e8e8';
    highlightColor = '#ffffff';
  } else if (game.roastLevel < 40) {
    // Warming - white to light cream
    const t = (game.roastLevel - 15) / 25;
    baseColor = lerpColor('#f8f8f8', '#fff5e6', t);
    shadowColor = lerpColor('#e8e8e8', '#f0e0c8', t);
    highlightColor = '#ffffff';
  } else if (game.roastLevel < 65) {
    // Toasting - cream to light golden
    const t = (game.roastLevel - 40) / 25;
    baseColor = lerpColor('#fff5e6', '#f4d03f', t);
    shadowColor = lerpColor('#f0e0c8', '#d4ac0d', t);
    highlightColor = lerpColor('#ffffff', '#fff9e6', t);
  } else if (game.roastLevel < 85) {
    // Golden - beautiful caramelized look
    const t = (game.roastLevel - 65) / 20;
    baseColor = lerpColor('#f4d03f', '#e6a117', t);
    shadowColor = lerpColor('#d4ac0d', '#c9920a', t);
    highlightColor = lerpColor('#fff9e6', '#ffe066', t);
  } else if (game.roastLevel < 105) {
    // Perfect golden brown - ideal s'more marshmallow
    const t = (game.roastLevel - 85) / 20;
    baseColor = lerpColor('#e6a117', '#d4841a', t);
    shadowColor = lerpColor('#c9920a', '#b87315', t);
    highlightColor = lerpColor('#ffe066', '#f5c842', t);
  } else if (game.roastLevel < 125) {
    // Overdone - getting darker but still edible
    const t = (game.roastLevel - 105) / 20;
    baseColor = lerpColor('#d4841a', '#8b5a2b', t);
    shadowColor = lerpColor('#b87315', '#6b4423', t);
    highlightColor = lerpColor('#f5c842', '#c9923a', t);
  } else if (game.roastLevel < 145) {
    // Burnt - dark brown to charred
    const t = (game.roastLevel - 125) / 20;
    baseColor = lerpColor('#8b5a2b', '#3d2817', t);
    shadowColor = lerpColor('#6b4423', '#2a1a0f', t);
    highlightColor = lerpColor('#c9923a', '#5c4030', t);
  } else {
    // Charcoal - completely burnt
    baseColor = '#1f1410';
    shadowColor = '#0f0a08';
    highlightColor = '#3a2a20';
  }

  // Fire glow when marshmallow is on fire
  if (game.mallowOnFire) {
    const fireGlow = 0.5 + Math.sin(game.frameCount * 0.3) * 0.3;
    const glowGrad = ctx.createRadialGradient(0, 0, size, 0, 0, size * 2.5);
    glowGrad.addColorStop(0, `rgba(255, 100, 0, ${fireGlow})`);
    glowGrad.addColorStop(0.5, `rgba(255, 50, 0, ${fireGlow * 0.5})`);
    glowGrad.addColorStop(1, 'rgba(255, 0, 0, 0)');
    ctx.fillStyle = glowGrad;
    ctx.beginPath();
    ctx.arc(0, 0, size * 2.5, 0, Math.PI * 2);
    ctx.fill();
  }

  // Marshmallow shadow
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.beginPath();
  ctx.roundRect(-mw + 3, -mh + 3, mw * 2, mh * 2, cornerR);
  ctx.fill();

  // Main marshmallow body - cylindrical shape
  const bodyGrad = ctx.createLinearGradient(-mw, 0, mw, 0);
  bodyGrad.addColorStop(0, shadowColor);
  bodyGrad.addColorStop(0.3, baseColor);
  bodyGrad.addColorStop(0.7, baseColor);
  bodyGrad.addColorStop(1, shadowColor);

  ctx.fillStyle = bodyGrad;
  ctx.beginPath();
  ctx.roundRect(-mw, -mh, mw * 2, mh * 2, cornerR);
  ctx.fill();

  // Top highlight
  ctx.fillStyle = highlightColor;
  ctx.globalAlpha = 0.4;
  ctx.beginPath();
  ctx.ellipse(-size * 0.15, -mh * 0.5, size * 0.35, size * 0.15, -0.2, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = 1;

  // Roast spots (gradual browning pattern)
  // Caramelization spots appear as marshmallow toasts
  if (game.roastLevel > 50) {
    const spotIntensity = Math.min((game.roastLevel - 50) / 80, 1);
    // Golden-brown spots that darken as roast progresses
    const spotDarkness = Math.min(game.roastLevel / 150, 1);
    const r = Math.round(180 - spotDarkness * 80);
    const g = Math.round(120 - spotDarkness * 70);
    const b = Math.round(60 - spotDarkness * 40);
    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${spotIntensity * 0.6})`;

    // Random-looking but consistent spots
    for (let i = 0; i < 5; i++) {
      const angle = i * 1.2 + rotation * 2;
      const spotX = Math.cos(angle) * mw * 0.6;
      const spotY = Math.sin(angle) * mh * 0.6;
      const spotSize = 3 + (i % 3) * 2;
      ctx.beginPath();
      ctx.arc(spotX, spotY, spotSize * spotIntensity, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Fire on marshmallow
  if (game.mallowOnFire) {
    // Mini flames
    for (let i = 0; i < 5; i++) {
      const flameAngle = (i / 5) * Math.PI * 2 + game.frameCount * 0.1;
      const flameX = Math.cos(flameAngle) * size * 0.6;
      const flameY = Math.sin(flameAngle) * size * 0.8 - 5;
      const flameH = 12 + Math.sin(game.frameCount * 0.3 + i) * 5;

      const flameGrad = ctx.createLinearGradient(flameX, flameY, flameX, flameY - flameH);
      flameGrad.addColorStop(0, 'rgba(255, 100, 0, 0.9)');
      flameGrad.addColorStop(0.5, 'rgba(255, 200, 0, 0.6)');
      flameGrad.addColorStop(1, 'rgba(255, 255, 0, 0)');

      ctx.fillStyle = flameGrad;
      ctx.beginPath();
      ctx.moveTo(flameX - 4, flameY);
      ctx.quadraticCurveTo(flameX, flameY - flameH, flameX + 4, flameY);
      ctx.fill();
    }

    // Spawn sparks (limit total to prevent memory issues)
    if (game.frameCount % 5 === 0 && game.sparkParticles.length < 50) {
      game.sparkParticles.push(createSparkParticle(x, y - size));
    }
  }

  // Stick insertion point
  ctx.fillStyle = '#6B5344';
  ctx.beginPath();
  ctx.ellipse(0, mh * 0.85, 4, 3, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}

function drawSparks() {
  // Filter first, then update and draw
  game.sparkParticles = game.sparkParticles.filter(p => p.life > 0);

  game.sparkParticles.forEach((p) => {
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.15; // gravity
    p.life--;

    const alpha = Math.max(0, p.life / p.maxLife);
    const radius = Math.max(0.1, p.size * alpha);
    ctx.fillStyle = `rgba(255, 200, 50, ${alpha})`;
    ctx.beginPath();
    ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
    ctx.fill();
  });
}

function drawPerfectZone() {
  // Visual indicator for the perfect roasting zone
  // Zone spans horizontally where marshmallow can reach
  const zoneLeft = W * 0.35;
  const zoneRight = W * 0.75;
  const zoneTop = game.perfectZoneTop;
  const zoneBot = game.perfectZoneBottom;
  const zoneWidth = zoneRight - zoneLeft;

  // Subtle gradient zone indicator
  const zoneGrad = ctx.createLinearGradient(0, zoneTop, 0, zoneBot);
  zoneGrad.addColorStop(0, 'rgba(100, 255, 100, 0.03)');
  zoneGrad.addColorStop(0.5, 'rgba(100, 255, 100, 0.08)');
  zoneGrad.addColorStop(1, 'rgba(100, 255, 100, 0.03)');

  ctx.fillStyle = zoneGrad;
  ctx.fillRect(zoneLeft, zoneTop, zoneWidth, zoneBot - zoneTop);

  // Zone border lines (dashed)
  ctx.strokeStyle = 'rgba(100, 255, 100, 0.25)';
  ctx.lineWidth = 1;
  ctx.setLineDash([8, 6]);
  ctx.beginPath();
  ctx.moveTo(zoneLeft, zoneTop);
  ctx.lineTo(zoneRight, zoneTop);
  ctx.moveTo(zoneLeft, zoneBot);
  ctx.lineTo(zoneRight, zoneBot);
  ctx.stroke();
  ctx.setLineDash([]);

  // Small label
  ctx.fillStyle = 'rgba(100, 255, 100, 0.4)';
  ctx.font = '10px Nunito, sans-serif';
  ctx.fillText('PERFECT', zoneRight + 5, (zoneTop + zoneBot) / 2 + 3);
}

function drawHUD() {
  // Status text updates - matches new color ranges
  const hudStatus = document.getElementById('hudStatus');
  let statusText = 'Raw';
  let statusClass = '';

  if (game.mallowOnFire) {
    statusText = 'ON FIRE!';
    statusClass = 'burning';
  } else if (game.roastLevel >= 145) {
    statusText = 'Charred';
    statusClass = 'burning';
  } else if (game.roastLevel >= 125) {
    statusText = 'Burnt';
    statusClass = 'burning';
  } else if (game.roastLevel >= 105) {
    statusText = 'Overdone';
    statusClass = 'burning';
  } else if (game.roastLevel >= 85) {
    statusText = 'Perfect!';
    statusClass = 'golden';
  } else if (game.roastLevel >= 65) {
    statusText = 'Golden';
    statusClass = 'golden';
  } else if (game.roastLevel >= 40) {
    statusText = 'Toasting';
    statusClass = '';
  } else if (game.roastLevel >= 15) {
    statusText = 'Warming';
    statusClass = '';
  }

  // Show "Pull up to finish!" hint when marshmallow is ready
  if (game.roastLevel >= 65 && game.roastLevel < 125 && !game.mallowOnFire) {
    if (game.finishZoneTimer > 0) {
      statusText = 'Making S\'more!';
      statusClass = 'golden';
    } else if (game.canFinish || game.roastLevel >= 65) {
      statusText += ' ‚Üë';
    }
  }

  hudStatus.textContent = statusText;
  hudStatus.className = 'hud-value ' + statusClass;

  document.getElementById('hudScore').textContent = Math.floor(game.score);
}

// Color lerp helper
function lerpColor(c1, c2, t) {
  const hex = (c) => parseInt(c.slice(1), 16);
  const r1 = (hex(c1) >> 16) & 255;
  const g1 = (hex(c1) >> 8) & 255;
  const b1 = hex(c1) & 255;
  const r2 = (hex(c2) >> 16) & 255;
  const g2 = (hex(c2) >> 8) & 255;
  const b2 = hex(c2) & 255;

  const r = Math.round(r1 + (r2 - r1) * t);
  const g = Math.round(g1 + (g2 - g1) * t);
  const b = Math.round(b1 + (b2 - b1) * t);

  return `rgb(${r},${g},${b})`;
}

// ==================== GAME LOOP ====================

function update() {
  // Always increment frame count for animations
  game.frameCount++;

  if (game.gameOver) {
    game.gameOverTimer++;
    if (game.gameOverTimer > 45 && gameRunning) {
      showResult();
    }
    return;
  }

  // Input - move hand up/down (raises/lowers the stick)
  if (keys.up) {
    game.handY = Math.max(game.handMinY, game.handY - game.handSpeed);
  }
  if (keys.down) {
    game.handY = Math.min(game.handMaxY, game.handY + game.handSpeed);
  }

  // Calculate marshmallow position from hand position + stick angle/length
  // (This is also done in drawStick, but we need it here for collision)
  const endX = game.handX + Math.cos(game.stickAngle) * game.stickLength;
  const endY = game.handY + Math.sin(game.stickAngle) * game.stickLength;
  game.mallowX = endX;
  game.mallowY = endY;

  // Rotate marshmallow on stick
  game.mallowRotation += game.mallowRotationSpeed;

  // Fire oscillation
  game.firePhase += game.fireSpeed;
  game.fireOffset = Math.sin(game.firePhase) * game.fireAmplitude;

  // Update zones based on fire position
  updateZones();

  // Determine roasting state based on marshmallow Y position
  const mallowY = game.mallowY;

  // Check if in burn zone (in flames)
  if (mallowY > game.burnZoneTop) {
    // In the fire! Catch fire!
    if (!game.mallowOnFire) {
      game.mallowOnFire = true;
      game.fireTimer = 0;
    }
    game.fireTimer++;
    game.mallowState = MALLOW_BURNING;
    // Burn faster when actually in the flames
    game.roastLevel += 0.8;
  }
  // Perfect zone
  else if (mallowY >= game.perfectZoneTop && mallowY <= game.perfectZoneBottom) {
    game.mallowState = MALLOW_TOASTING;
    if (!game.mallowOnFire) {
      game.roastLevel += 0.05; // Slow, controlled roasting
    }
    game.perfectTime++;

    // Bonus points for staying in perfect zone
    if (game.roastLevel >= 50 && game.roastLevel < 100) {
      game.score += 2 * game.scoreMultiplier;
      game.scoreMultiplier = Math.min(game.scoreMultiplier + 0.001, 3);
    } else {
      game.score += 0.5;
    }
  }
  // Above perfect zone (cooling/safe zone)
  else if (mallowY < game.perfectZoneTop) {
    game.mallowState = MALLOW_RAW;
    // Very slow roasting from ambient heat if somewhat close to fire
    if (!game.mallowOnFire) {
      const distFromZone = game.perfectZoneTop - mallowY;
      if (distFromZone < 80) {
        game.roastLevel += 0.008;
      }
    }
    game.scoreMultiplier = Math.max(1, game.scoreMultiplier - 0.01);
    game.score += 0.1;

    // Can put out fire by moving up high enough
    if (game.mallowOnFire && mallowY < game.perfectZoneTop - 40) {
      game.mallowOnFire = false;
    }

    // WIN CONDITION: Pull roasted marshmallow up high to finish!
    // Must be roasted to at least "Golden" (65+) and pulled up high
    if (game.roastLevel >= 65 && !game.mallowOnFire && mallowY < game.perfectZoneTop - 60) {
      game.canFinish = true;
      game.finishZoneTimer++;
      // Hold for ~1 second to finish
      if (game.finishZoneTimer > 60) {
        game.gameOver = true;
        game.gameOverTimer = 0;
      }
    } else {
      game.finishZoneTimer = Math.max(0, game.finishZoneTimer - 2); // Decay if not in finish zone
    }
  }
  // Below perfect but above burn
  else {
    game.mallowState = MALLOW_TOASTING;
    if (!game.mallowOnFire) {
      game.roastLevel += 0.15; // Faster roasting, risky
    }
    game.score += 1;
  }

  // If on fire but pulled out of flames, still burns but slower
  if (game.mallowOnFire && mallowY <= game.burnZoneTop) {
    game.roastLevel += 0.2;
  }

  // Check for burnt (game over) - either roast level too high OR on fire too long
  if (game.roastLevel >= 150 || game.fireTimer > 180) {
    game.mallowState = MALLOW_BURNT;
    game.gameOver = true;
    game.gameOverTimer = 0;
  }

  // Difficulty progression
  game.levelTimer++;
  if (game.levelTimer > 600) { // Every ~10 seconds
    game.levelTimer = 0;
    game.level++;
    game.fireSpeed = Math.min(0.025, game.fireSpeed + 0.002);
    game.fireAmplitude = Math.min(H * 0.12, game.fireAmplitude + H * 0.005);
  }

  drawHUD();
}

function render() {
  if (!game) return;

  ctx.clearRect(0, 0, W, H);

  drawBackground();
  drawStump();
  drawFirePit();
  drawSmoke();
  drawPerfectZone();
  drawFire();
  drawStick();
  drawMarshmallow();
  drawSparks();
}

function gameLoop() {
  if (!gameRunning) return;
  update();
  render();
  animId = requestAnimationFrame(gameLoop);
}

// ==================== GAME FLOW ====================

function startGame() {
  initAudio();
  document.getElementById('startScreen').classList.add('hidden');
  document.getElementById('hud').classList.remove('hidden');
  if (isMobile) document.getElementById('mobileControls').classList.add('visible');

  initGame();

  if (!shownControls) {
    shownControls = true;
    document.getElementById('controlsOverlay').classList.add('visible');
  } else {
    gameRunning = true;
    gameLoop();
  }
}

function dismissControls() {
  document.getElementById('controlsOverlay').classList.remove('visible');
  gameRunning = true;
  gameLoop();
}

function showResult() {
  // Prevent multiple calls
  if (!gameRunning) return;

  gameRunning = false;
  cancelAnimationFrame(animId);

  const score = Math.floor(game.score);
  if (score > bestScore) {
    bestScore = score;
    localStorage.setItem('marshmallowBest', bestScore.toString());
  }

  let emoji, title;
  // Feedback based on final roast level (using new ranges)
  if (game.roastLevel >= 145) {
    emoji = '‚¨õ';
    title = 'Charcoal Briquette!';
  } else if (game.roastLevel >= 125) {
    emoji = 'üí®';
    title = 'Oops, Burnt!';
  } else if (game.roastLevel >= 105) {
    emoji = 'üòÖ';
    title = 'A Bit Overdone';
  } else if (game.roastLevel >= 85) {
    emoji = 'üòã';
    title = 'Perfect S\'more!';
  } else if (game.roastLevel >= 65) {
    emoji = 'üç°';
    title = 'Golden & Tasty!';
  } else {
    emoji = 'ü§î';
    title = 'Needs More Time';
  }

  // Override with special achievements
  if (game.perfectTime > 300 && game.roastLevel >= 85 && game.roastLevel < 105) {
    emoji = 'üèÜ';
    title = 'Master Roaster!';
  } else if (score > 500 && game.roastLevel < 125) {
    emoji = '‚≠ê';
    title = 'S\'more Expert!';
  }

  document.getElementById('resultEmoji').textContent = emoji;
  document.getElementById('resultTitle').textContent = title;
  document.getElementById('resultScore').textContent = `Score: ${score}`;
  document.getElementById('resultBest').textContent = `Best: ${bestScore}`;
  document.getElementById('resultOverlay').classList.add('visible');
}

function restartGame() {
  document.getElementById('resultOverlay').classList.remove('visible');
  initGame();
  gameRunning = true;
  gameLoop();
}

function backToMenu() {
  gameRunning = false;
  cancelAnimationFrame(animId);
  document.getElementById('hud').classList.add('hidden');
  document.getElementById('mobileControls').classList.remove('visible');
  document.getElementById('resultOverlay').classList.remove('visible');
  document.getElementById('startScreen').classList.remove('hidden');
  ctx.clearRect(0, 0, W, H);
}

// ==================== INPUT ====================

// Keyboard
document.addEventListener('keydown', e => {
  if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
    keys.up = true;
    e.preventDefault();
  }
  if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
    keys.down = true;
    e.preventDefault();
  }
});
document.addEventListener('keyup', e => {
  if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') keys.up = false;
  if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') keys.down = false;
});

// Mobile touch buttons
function setupCtrl(id, dir) {
  const el = document.getElementById(id);
  if (!el) return;
  const start = () => { keys[dir] = true; el.classList.add('pressed'); };
  const end = () => { keys[dir] = false; el.classList.remove('pressed'); };
  el.addEventListener('touchstart', e => { e.preventDefault(); start(); }, { passive: false });
  el.addEventListener('touchend', e => { e.preventDefault(); end(); }, { passive: false });
  el.addEventListener('touchcancel', end);
  el.addEventListener('mousedown', start);
  el.addEventListener('mouseup', end);
  el.addEventListener('mouseleave', end);
}
setupCtrl('btnUp', 'up');
setupCtrl('btnDown', 'down');

// Prevent scroll on touch
document.addEventListener('touchmove', e => {
  if (gameRunning) e.preventDefault();
}, { passive: false });

// ==================== MENU EFFECTS ====================

// Stars
const starsContainer = document.getElementById('stars');
for (let i = 0; i < 60; i++) {
  const s = document.createElement('div');
  s.className = 'star';
  s.style.left = Math.random() * 100 + '%';
  s.style.top = Math.random() * 60 + '%';
  s.style.setProperty('--dur', (2 + Math.random() * 4) + 's');
  s.style.setProperty('--max-o', (0.3 + Math.random() * 0.5).toFixed(2));
  s.style.animationDelay = (Math.random() * 5) + 's';
  s.style.width = s.style.height = (1.5 + Math.random() * 2) + 'px';
  starsContainer.appendChild(s);
}

// Fireflies
for (let i = 0; i < 8; i++) {
  const f = document.createElement('div');
  f.className = 'firefly';
  f.style.left = (20 + Math.random() * 60) + '%';
  f.style.top = (40 + Math.random() * 40) + '%';
  f.style.setProperty('--dx', (Math.random() - 0.5) * 60 + 'px');
  f.style.setProperty('--dy', (Math.random() - 0.5) * 40 + 'px');
  f.style.animationDelay = (Math.random() * 8) + 's';
  f.style.animationDuration = (6 + Math.random() * 4) + 's';
  starsContainer.appendChild(f);
}
</script>
</body>
</html>
